#!/usr/bin/env python3
"""
ÈöéÂ±§ÁöÑ„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆóÂô®

ÈÅãÁî®ÊñπÈáù„Å´Âü∫„Å•„Åè3ÊÆµÈöé„ÅÆ„ÉÜ„ÇØ„Éã„Ç´„É´ÂàÜÊûê:
1. Â§ßÂ±ÄÂà§Êñ≠ÔºàD1„ÉªH4Ôºâ: „Éà„É¨„É≥„ÉâÊñπÂêë„ÅÆÁ¢∫ÂÆö
2. Êà¶Ë°ìÂà§Êñ≠ÔºàH1Ôºâ: „Ç®„É≥„Éà„É™„Éº„Çæ„Éº„É≥„ÅÆÁâπÂÆö
3. Âü∑Ë°åÂà§Êñ≠ÔºàM5Ôºâ: „Ç®„É≥„Éà„É™„Éº„Çø„Ç§„Éü„É≥„Ç∞„ÅÆÊúÄÈÅ©Âåñ
"""

import logging
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timezone

try:
    import talib
except ImportError:
    talib = None

try:
    import pandas as pd
except ImportError:
    pd = None

try:
    import numpy as np
except ImportError:
    np = None

logger = logging.getLogger(__name__)


class TechnicalIndicatorCalculator:
    """ÈöéÂ±§ÁöÑ„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆóÂô®"""
    
    def __init__(self):
        """ÂàùÊúüÂåñ"""
        self.logger = logging.getLogger(__name__)
        
        # „Éï„Ç£„Éú„Éä„ÉÉ„ÉÅË®≠ÂÆö
        self.fibonacci_config = {
            "trend_direction": {  # Â§ßÂ±ÄÂà§Êñ≠ÔºàD1„ÉªH4Ôºâ
                "1d": {
                    "swing_periods": [20, 50, 100],
                    "levels": [0.0, 0.236, 0.382, 0.5, 0.618, 0.786, 1.0],
                    "extensions": [1.272, 1.414, 1.618, 2.0]
                },
                "4h": {
                    "swing_periods": [10, 20, 40],
                    "levels": [0.0, 0.236, 0.382, 0.5, 0.618, 0.786, 1.0],
                    "extensions": [1.272, 1.414, 1.618]
                }
            },
            "zone_decision": {  # Êà¶Ë°ìÂà§Êñ≠ÔºàH1Ôºâ
                "1h": {
                    "swing_periods": [5, 10, 20],
                    "levels": [0.0, 0.236, 0.382, 0.5, 0.618, 0.786, 1.0],
                    "extensions": [1.272, 1.414]
                }
            },
            "timing_execution": {  # Âü∑Ë°åÂà§Êñ≠ÔºàM5Ôºâ
                "5m": {
                    "swing_periods": [3, 5, 10],
                    "levels": [0.0, 0.236, 0.382, 0.5, 0.618, 0.786, 1.0],
                    "extensions": [1.272]
                }
            }
        }
        
        # ÈÅãÁî®ÊñπÈáù„Å´Âü∫„Å•„ÅèÊåáÊ®ôË®≠ÂÆö
        self.indicator_config = {
            "trend_direction": {  # Â§ßÂ±ÄÂà§Êñ≠ÔºàD1„ÉªH4Ôºâ
                "timeframes": ["1d", "4h"],
                "indicators": {
                    "EMA_21": 21,
                    "EMA_55": 55,
                    "EMA_200": 200,
                    "MACD": (12, 26, 9),
                    "ATR_14": 14,
                    "RSI_14": 14
                }
            },
            "zone_decision": {  # Êà¶Ë°ìÂà§Êñ≠ÔºàH1Ôºâ
                "timeframes": ["1h"],
                "indicators": {
                    "EMA_21": 21,
                    "EMA_55": 55,
                    "MACD": (12, 26, 9),
                    "ATR_14": 14,
                    "RSI_14": 14,
                    "Bollinger": (20, 2.0),
                    "Stochastic": (14, 3, 3),
                    "Williams_R": 14
                }
            },
            "timing_execution": {  # Âü∑Ë°åÂà§Êñ≠ÔºàM5Ôºâ
                "timeframes": ["5m"],
                "indicators": {
                    "EMA_21": 21,
                    "RSI_14": 14,
                    "RSI_7": 7,
                    "Stochastic": (14, 3, 3),
                    "Williams_R": 14,
                    "ATR_14": 14,
                    "Volume_SMA_20": 20
                }
            },
            "trend_reinforcement": {  # „Éà„É¨„É≥„ÉâË£úÂº∑ÔºàÂÖ®ÊôÇÈñìË∂≥Ôºâ
                "timeframes": ["5m", "15m", "1h", "4h", "1d"],
                "indicators": {
                    "EMA_21": 21,
                    "MACD": (12, 26, 9),
                    "ATR_14": 14,
                    "RSI_14": 14
                }
            }
        }
    
    def calculate_all_indicators(self, data: Dict[str, pd.DataFrame]) -> Dict[str, pd.DataFrame]:
        """ÂÖ®ÊôÇÈñìË∂≥„ÅÆ„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ô„ÇíË®àÁÆó"""
        self.logger.info("üìä ÈöéÂ±§ÁöÑ„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆóÈñãÂßã")
        
        result = {}
        
        for timeframe, df in data.items():
            self.logger.info(f"‚è∞ {timeframe}Ë∂≥„ÅÆÊåáÊ®ôË®àÁÆó‰∏≠...")
            
            # „Éá„Éº„Çø„ÅÆÂü∫Êú¨„ÉÅ„Çß„ÉÉ„ÇØ
            if not self._validate_data(df):
                self.logger.warning(f"‚ö†Ô∏è {timeframe}Ë∂≥„ÅÆ„Éá„Éº„Çø„ÅåÁÑ°Âäπ„Åß„Åô")
                continue
            
            # ÊåáÊ®ôË®àÁÆó
            df_with_indicators = self._calculate_timeframe_indicators(df, timeframe)
            result[timeframe] = df_with_indicators
            
            self.logger.info(f"‚úÖ {timeframe}Ë∂≥: {len(df_with_indicators.columns)}ÂÄã„ÅÆÊåáÊ®ô„ÇíË®àÁÆó")
        
        self.logger.info("üìä ÈöéÂ±§ÁöÑ„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆóÂÆå‰∫Ü")
        return result
    
    def _validate_data(self, df: pd.DataFrame) -> bool:
        """„Éá„Éº„Çø„ÅÆÂ¶•ÂΩìÊÄß„ÉÅ„Çß„ÉÉ„ÇØ"""
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        
        if df.empty:
            return False
        
        for col in required_columns:
            if col not in df.columns:
                self.logger.error(f"‚ùå ÂøÖÈ†à„Ç´„É©„É† '{col}' „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
                return False
        
        # „Éá„Éº„ÇøÂûã„Çífloat64„Å´Â§âÊèõÔºàTA-Lib„ÅÆË¶ÅÊ±ÇÔºâ
        for col in required_columns:
            if col in df.columns:
                df[col] = df[col].astype(np.float64)
        
        # „Éá„Éº„Çø„ÅÆÂü∫Êú¨Áµ±Ë®à„ÉÅ„Çß„ÉÉ„ÇØ
        if df['close'].isna().all():
            self.logger.error("‚ùå ‰æ°Ê†º„Éá„Éº„Çø„ÅåÂÖ®„Å¶NaN„Åß„Åô")
            return False
        
        # Volume„Éá„Éº„Çø„ÅÆÂèØÁî®ÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
        self._check_volume_availability(df)
        
        return True
    
    def _check_volume_availability(self, df: pd.DataFrame) -> bool:
        """Volume„Éá„Éº„Çø„ÅÆÂèØÁî®ÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ"""
        volume_available = not (df['volume'] == 0).all()
        
        if not volume_available:
            # Volume„Éá„Éº„Çø„ÅåÂà©Áî®„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÅØË≠¶Âëä„ÇíÈùûË°®Á§∫ÔºàYahoo Finance API„ÅÆÂà∂ÈôêÔºâ
            # self.logger.warning("‚ö†Ô∏è Volume„Éá„Éº„Çø„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„ÇìÔºà„Åô„Åπ„Å¶0.0Ôºâ")
            # VolumeÈñ¢ÈÄ£„ÅÆÊåáÊ®ô„ÇíÁÑ°ÂäπÂåñ
            df['volume_available'] = False
        else:
            df['volume_available'] = True
            self.logger.info("‚úÖ Volume„Éá„Éº„Çø„ÅåÂà©Áî®ÂèØËÉΩ„Åß„Åô")
        
        return volume_available
    
    def _calculate_timeframe_indicators(self, df: pd.DataFrame, timeframe: str) -> pd.DataFrame:
        """ÊôÇÈñìË∂≥Âà•„ÅÆÊåáÊ®ôË®àÁÆó"""
        df_result = df.copy()
        
        # 1. „Éà„É¨„É≥„ÉâÁ≥ªÊåáÊ®ô
        df_result = self._calculate_trend_indicators(df_result)
        
        # 2. „É¢„É°„É≥„Çø„É†Á≥ªÊåáÊ®ô
        df_result = self._calculate_momentum_indicators(df_result)
        
        # 3. „Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£Á≥ªÊåáÊ®ô
        df_result = self._calculate_volatility_indicators(df_result)
        
        # 4. „Éú„É™„É•„Éº„É†Á≥ªÊåáÊ®ô
        df_result = self._calculate_volume_indicators(df_result)
        
        # 5. „Éï„Ç£„Éú„Éä„ÉÉ„ÉÅÊåáÊ®ô
        df_result = self._calculate_fibonacci_indicators(df_result, timeframe)
        
        # 6. ÊôÇÈñìË∂≥Âõ∫Êúâ„ÅÆÊåáÊ®ô
        df_result = self._calculate_timeframe_specific_indicators(df_result, timeframe)
        
        # 7. „É≠„Éº„ÇΩ„ÇØË∂≥ÂàÜÊûêÊåáÊ®ô
        df_result = self._calculate_candle_analysis_indicators(df_result)
        
        return df_result
    
    def _calculate_trend_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """„Éà„É¨„É≥„ÉâÁ≥ªÊåáÊ®ô„ÅÆË®àÁÆó"""
        try:
            # EMA (Exponential Moving Average)
            df['EMA_21'] = talib.EMA(df['close'], timeperiod=21)
            df['EMA_55'] = talib.EMA(df['close'], timeperiod=55)
            df['EMA_200'] = talib.EMA(df['close'], timeperiod=200)
            
            # SMA (Simple Moving Average)
            df['SMA_20'] = talib.SMA(df['close'], timeperiod=20)
            df['SMA_50'] = talib.SMA(df['close'], timeperiod=50)
            df['SMA_200'] = talib.SMA(df['close'], timeperiod=200)
            
            # MACD (Moving Average Convergence Divergence)
            macd, macd_signal, macd_hist = talib.MACD(
                df['close'], fastperiod=12, slowperiod=26, signalperiod=9
            )
            df['MACD'] = macd
            df['MACD_Signal'] = macd_signal
            df['MACD_Histogram'] = macd_hist
            
            # ADX (Average Directional Index)
            df['ADX'] = talib.ADX(df['high'], df['low'], df['close'], timeperiod=14)
            df['ADXR'] = talib.ADXR(df['high'], df['low'], df['close'], timeperiod=14)
            
            # „Éà„É¨„É≥„ÉâÊñπÂêë„ÅÆÂà§ÂÆö
            df['Trend_Direction'] = self._determine_trend_direction(df)
            
        except Exception as e:
            self.logger.error(f"‚ùå „Éà„É¨„É≥„ÉâÁ≥ªÊåáÊ®ôË®àÁÆó„Ç®„É©„Éº: {e}")
        
        return df
    
    def _calculate_momentum_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """„É¢„É°„É≥„Çø„É†Á≥ªÊåáÊ®ô„ÅÆË®àÁÆó"""
        try:
            # RSI (Relative Strength Index)
            df['RSI_14'] = talib.RSI(df['close'], timeperiod=14)
            df['RSI_21'] = talib.RSI(df['close'], timeperiod=21)
            df['RSI_7'] = talib.RSI(df['close'], timeperiod=7)
            
            # Stochastic Oscillator
            slowk, slowd = talib.STOCH(
                df['high'], df['low'], df['close'],
                fastk_period=14, slowk_period=3, slowd_period=3
            )
            df['Stochastic_K'] = slowk
            df['Stochastic_D'] = slowd
            
            # Williams %R
            df['Williams_R'] = talib.WILLR(df['high'], df['low'], df['close'], timeperiod=14)
            
            # „É¢„É°„É≥„Çø„É†Áä∂ÊÖã„ÅÆÂà§ÂÆö
            df['Momentum_State'] = self._determine_momentum_state(df)
            
        except Exception as e:
            self.logger.error(f"‚ùå „É¢„É°„É≥„Çø„É†Á≥ªÊåáÊ®ôË®àÁÆó„Ç®„É©„Éº: {e}")
        
        return df
    
    def _calculate_volatility_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """„Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£Á≥ªÊåáÊ®ô„ÅÆË®àÁÆó"""
        try:
            # ATR (Average True Range)
            df['ATR_14'] = talib.ATR(df['high'], df['low'], df['close'], timeperiod=14)
            df['ATR_21'] = talib.ATR(df['high'], df['low'], df['close'], timeperiod=21)
            
            # Bollinger Bands
            bb_upper, bb_middle, bb_lower = talib.BBANDS(
                df['close'], timeperiod=20, nbdevup=2, nbdevdn=2
            )
            df['BB_Upper'] = bb_upper
            df['BB_Middle'] = bb_middle
            df['BB_Lower'] = bb_lower
            
            # Bollinger Band Position
            df['BB_Position'] = (df['close'] - df['BB_Lower']) / (df['BB_Upper'] - df['BB_Lower'])
            
            # Bollinger Band Width
            df['bollinger_width'] = (df['BB_Upper'] - df['BB_Lower']) / df['BB_Middle']
            
            # „Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£Áä∂ÊÖã„ÅÆÂà§ÂÆö
            df['Volatility_State'] = self._determine_volatility_state(df)
            
        except Exception as e:
            self.logger.error(f"‚ùå „Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£Á≥ªÊåáÊ®ôË®àÁÆó„Ç®„É©„Éº: {e}")
        
        return df
    
    def _calculate_volume_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """„Éú„É™„É•„Éº„É†Á≥ªÊåáÊ®ô„ÅÆË®àÁÆó"""
        try:
            # Volume SMA
            df['Volume_SMA_20'] = df['volume'].rolling(window=20).mean()
            df['Volume_SMA_50'] = df['volume'].rolling(window=50).mean()
            
            # Volume Ratio („Çº„É≠Èô§ÁÆó„ÇíÂõûÈÅø)
            df['Volume_Ratio'] = np.where(
                df['Volume_SMA_20'] != 0,
                df['volume'] / df['Volume_SMA_20'],
                1.0  # Volume_SMA_20„Åå0„ÅÆÂ†¥Âêà„ÅØ1.0„ÇíËøî„Åô
            )
            
            # OBV (On Balance Volume)
            df['OBV'] = talib.OBV(df['close'], df['volume'])
            
            # „Éú„É™„É•„Éº„É†Áä∂ÊÖã„ÅÆÂà§ÂÆö
            df['Volume_State'] = self._determine_volume_state(df)
            
        except Exception as e:
            self.logger.error(f"‚ùå „Éú„É™„É•„Éº„É†Á≥ªÊåáÊ®ôË®àÁÆó„Ç®„É©„Éº: {e}")
        
        return df
    
    def _calculate_fibonacci_indicators(self, df: pd.DataFrame, timeframe: str) -> pd.DataFrame:
        """„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅÊåáÊ®ô„ÅÆË®àÁÆó"""
        try:
            # ÊôÇÈñìË∂≥Âà•„ÅÆ„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅË®≠ÂÆö„ÇíÂèñÂæó
            fib_config = self._get_fibonacci_config(timeframe)
            if not fib_config:
                return df
            
            # „Çπ„Ç§„É≥„Ç∞„Éù„Ç§„É≥„Éà„ÅÆÁâπÂÆö
            swing_points = self._identify_swing_points(df, fib_config['swing_periods'])
            
            # „Éï„Ç£„Éú„Éä„ÉÉ„ÉÅ„É¨„Éô„É´„ÅÆË®àÁÆó
            fib_levels = self._calculate_fibonacci_levels(swing_points, fib_config['levels'])
            fib_extensions = self._calculate_fibonacci_extensions(swing_points, fib_config['extensions'])
            
            # „Éá„Éº„Çø„Éï„É¨„Éº„É†„Å´ËøΩÂä†
            for level, value in fib_levels.items():
                df[f'Fib_{level}'] = value
            
            for ext, value in fib_extensions.items():
                df[f'Fib_Ext_{ext}'] = value
            
            # „Éï„Ç£„Éú„Éä„ÉÉ„ÉÅ‰ΩçÁΩÆ„ÅÆÂà§ÂÆö
            df['Fibonacci_Position'] = self._determine_fibonacci_position(df, fib_levels)
            
        except Exception as e:
            self.logger.error(f"‚ùå „Éï„Ç£„Éú„Éä„ÉÉ„ÉÅÊåáÊ®ôË®àÁÆó„Ç®„É©„Éº ({timeframe}): {e}")
        
        return df
    
    def _get_fibonacci_config(self, timeframe: str) -> Optional[Dict]:
        """ÊôÇÈñìË∂≥Âà•„ÅÆ„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅË®≠ÂÆö„ÇíÂèñÂæó"""
        for analysis_type, configs in self.fibonacci_config.items():
            if timeframe in configs:
                return configs[timeframe]
        return None
    
    def _identify_swing_points(self, df: pd.DataFrame, swing_periods: List[int]) -> Dict:
        """„Çπ„Ç§„É≥„Ç∞„Éù„Ç§„É≥„Éà„ÅÆÁâπÂÆö"""
        swing_points = {}
        
        for period in swing_periods:
            # „É≠„Éº„Ç´„É´„Éè„Ç§„Éª„É≠„Éº„ÇíÁâπÂÆö
            window = period * 2 + 1
            if window > len(df):
                continue
                
            highs = df['high'].rolling(window=window, center=True).max()
            lows = df['low'].rolling(window=window, center=True).min()
            
            # „Çπ„Ç§„É≥„Ç∞„Éè„Ç§„Éª„É≠„Éº„ÅÆÊù°‰ª∂„ÇíÁ∑©Âíå
            swing_highs = df[df['high'] >= highs * 0.999].dropna()  # 0.1%„ÅÆË®±ÂÆπË™§Â∑Æ
            swing_lows = df[df['low'] <= lows * 1.001].dropna()     # 0.1%„ÅÆË®±ÂÆπË™§Â∑Æ
            
            # ÊúÄ‰ΩéÈôê„ÅÆ„Éá„Éº„Çø„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if len(swing_highs) > 0 and len(swing_lows) > 0:
                swing_points[f'period_{period}'] = {
                    'swing_highs': swing_highs,
                    'swing_lows': swing_lows
                }
        
        return swing_points
    
    def _calculate_fibonacci_levels(self, swing_points: Dict, levels: List[float]) -> Dict:
        """„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅ„É¨„Éô„É´„ÅÆË®àÁÆó"""
        fib_levels = {}
        
        # ÊúÄÊñ∞„ÅÆ„Çπ„Ç§„É≥„Ç∞„Éù„Ç§„É≥„Éà„Çí‰ΩøÁî®
        latest_swing = None
        for period_key, points in swing_points.items():
            if not points['swing_highs'].empty and not points['swing_lows'].empty:
                latest_swing = points
                break
        
        if not latest_swing:
            return fib_levels
        
        # ÊúÄÊñ∞„ÅÆ„Çπ„Ç§„É≥„Ç∞„Éè„Ç§„Éª„É≠„Éº„ÇíÂèñÂæó
        latest_high = latest_swing['swing_highs'].iloc[-1]['high']
        latest_low = latest_swing['swing_lows'].iloc[-1]['low']
        
        # „Éï„Ç£„Éú„Éä„ÉÉ„ÉÅ„É¨„Éô„É´„ÇíË®àÁÆó
        diff = latest_high - latest_low
        for level in levels:
            fib_levels[level] = latest_high - (diff * level)
        
        return fib_levels
    
    def _calculate_fibonacci_extensions(self, swing_points: Dict, extensions: List[float]) -> Dict:
        """„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅ„Ç®„ÇØ„Çπ„ÉÜ„É≥„Ç∑„Éß„É≥„ÅÆË®àÁÆó"""
        fib_extensions = {}
        
        # ÊúÄÊñ∞„ÅÆ„Çπ„Ç§„É≥„Ç∞„Éù„Ç§„É≥„Éà„Çí‰ΩøÁî®
        latest_swing = None
        for period_key, points in swing_points.items():
            if not points['swing_highs'].empty and not points['swing_lows'].empty:
                latest_swing = points
                break
        
        if not latest_swing:
            return fib_extensions
        
        # ÊúÄÊñ∞„ÅÆ„Çπ„Ç§„É≥„Ç∞„Éè„Ç§„Éª„É≠„Éº„ÇíÂèñÂæó
        latest_high = latest_swing['swing_highs'].iloc[-1]['high']
        latest_low = latest_swing['swing_lows'].iloc[-1]['low']
        
        # „Éï„Ç£„Éú„Éä„ÉÉ„ÉÅ„Ç®„ÇØ„Çπ„ÉÜ„É≥„Ç∑„Éß„É≥„ÇíË®àÁÆó
        diff = latest_high - latest_low
        for ext in extensions:
            fib_extensions[ext] = latest_high + (diff * (ext - 1.0))
        
        return fib_extensions
    
    def _determine_fibonacci_position(self, df: pd.DataFrame, fib_levels: Dict) -> pd.Series:
        """„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅ‰ΩçÁΩÆ„ÅÆÂà§ÂÆö"""
        if not fib_levels:
            return pd.Series('UNKNOWN', index=df.index)
        
        current_price = df['close']
        position = pd.Series('UNKNOWN', index=df.index)
        
        # „Éï„Ç£„Éú„Éä„ÉÉ„ÉÅ„É¨„Éô„É´„Å®„ÅÆÈñ¢‰øÇ„ÇíÂà§ÂÆö
        for i, (level, price) in enumerate(sorted(fib_levels.items())):
            if i == 0:
                # ÊúÄÂàù„ÅÆ„É¨„Éô„É´
                position[current_price >= price] = f'ABOVE_{level}'
            else:
                # Ââç„ÅÆ„É¨„Éô„É´„Å®„ÅÆÈñì
                prev_level = sorted(fib_levels.items())[i-1][0]
                prev_price = sorted(fib_levels.items())[i-1][1]
                mask = (current_price >= price) & (current_price < prev_price)
                position[mask] = f'BETWEEN_{prev_level}_{level}'
        
        return position
    
    def _calculate_timeframe_specific_indicators(self, df: pd.DataFrame, timeframe: str) -> pd.DataFrame:
        """ÊôÇÈñìË∂≥Âõ∫Êúâ„ÅÆÊåáÊ®ôË®àÁÆó"""
        try:
            # ÊôÇÈñìË∂≥Âà•„ÅÆÁâπÂà•„Å™Âá¶ÁêÜ
            if timeframe in ["1d", "4h"]:  # Â§ßÂ±ÄÂà§Êñ≠
                df = self._calculate_trend_direction_indicators(df)
            elif timeframe == "1h":  # Êà¶Ë°ìÂà§Êñ≠
                df = self._calculate_zone_decision_indicators(df)
            elif timeframe == "5m":  # Âü∑Ë°åÂà§Êñ≠
                df = self._calculate_timing_execution_indicators(df)
            
            # ÂÖ®ÊôÇÈñìË∂≥ÂÖ±ÈÄö„ÅÆ„Éà„É¨„É≥„ÉâË£úÂº∑ÊåáÊ®ô
            df = self._calculate_trend_reinforcement_indicators(df)
            
        except Exception as e:
            self.logger.error(f"‚ùå ÊôÇÈñìË∂≥Âõ∫ÊúâÊåáÊ®ôË®àÁÆó„Ç®„É©„Éº ({timeframe}): {e}")
        
        return df
    
    def _calculate_trend_direction_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """Â§ßÂ±ÄÂà§Êñ≠ÊåáÊ®ô„ÅÆË®àÁÆó"""
        try:
            # Èï∑Êúü„Éà„É¨„É≥„Éâ„ÅÆÂº∑Â∫¶
            df['Long_Trend_Strength'] = self._calculate_trend_strength(df, periods=[21, 55, 200])
            
            # „Éà„É¨„É≥„Éâ„ÅÆ‰∏ÄË≤´ÊÄß
            df['Trend_Consistency'] = self._calculate_trend_consistency(df)
            
        except Exception as e:
            self.logger.error(f"‚ùå Â§ßÂ±ÄÂà§Êñ≠ÊåáÊ®ôË®àÁÆó„Ç®„É©„Éº: {e}")
        
        return df
    
    def _calculate_zone_decision_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """Êà¶Ë°ìÂà§Êñ≠ÊåáÊ®ô„ÅÆË®àÁÆó"""
        try:
            # „Ç®„É≥„Éà„É™„Éº„Çæ„Éº„É≥„ÅÆÁâπÂÆö
            df['Entry_Zone'] = self._identify_entry_zones(df)
            
            # „Çµ„Éù„Éº„Éà„Éª„É¨„Ç∏„Çπ„Çø„É≥„Çπ„É¨„Éô„É´
            df['Support_Level'] = self._calculate_support_level(df)
            df['Resistance_Level'] = self._calculate_resistance_level(df)
            
        except Exception as e:
            self.logger.error(f"‚ùå Êà¶Ë°ìÂà§Êñ≠ÊåáÊ®ôË®àÁÆó„Ç®„É©„Éº: {e}")
        
        return df
    
    def _calculate_timing_execution_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """Âü∑Ë°åÂà§Êñ≠ÊåáÊ®ô„ÅÆË®àÁÆó"""
        try:
            # „Ç®„É≥„Éà„É™„Éº„Çø„Ç§„Éü„É≥„Ç∞
            df['Entry_Timing'] = self._identify_entry_timing(df)
            
            # Áü≠Êúü„É¢„É°„É≥„Çø„É†
            df['Short_Momentum'] = self._calculate_short_momentum(df)
            
        except Exception as e:
            self.logger.error(f"‚ùå Âü∑Ë°åÂà§Êñ≠ÊåáÊ®ôË®àÁÆó„Ç®„É©„Éº: {e}")
        
        return df
    
    def _calculate_trend_reinforcement_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """„Éà„É¨„É≥„ÉâË£úÂº∑ÊåáÊ®ô„ÅÆË®àÁÆó"""
        try:
            # „Éà„É¨„É≥„Éâ„ÅÆË£úÂº∑Â∫¶
            df['Trend_Reinforcement'] = self._calculate_trend_reinforcement_strength(df)
            
            # ÈÄÜÂºµ„ÇäÊù°‰ª∂„ÅÆÂà§ÂÆö
            df['Counter_Trend_Condition'] = self._check_counter_trend_conditions(df)
            
        except Exception as e:
            self.logger.error(f"‚ùå „Éà„É¨„É≥„ÉâË£úÂº∑ÊåáÊ®ôË®àÁÆó„Ç®„É©„Éº: {e}")
        
        return df
    
    # Âà§ÂÆö„É≠„Ç∏„ÉÉ„ÇØ
    def _determine_trend_direction(self, df: pd.DataFrame) -> pd.Series:
        """„Éà„É¨„É≥„ÉâÊñπÂêë„ÅÆÂà§ÂÆö"""
        conditions = [
            (df['EMA_21'] > df['EMA_55']) & (df['EMA_55'] > df['EMA_200']),  # ‰∏äÊòá
            (df['EMA_21'] < df['EMA_55']) & (df['EMA_55'] < df['EMA_200']),  # ‰∏ãÈôç
        ]
        choices = ['BULLISH', 'BEARISH']
        return pd.Series(np.select(conditions, choices, default='SIDEWAYS'), index=df.index)
    
    def _determine_momentum_state(self, df: pd.DataFrame) -> pd.Series:
        """„É¢„É°„É≥„Çø„É†Áä∂ÊÖã„ÅÆÂà§ÂÆö"""
        conditions = [
            (df['RSI_14'] > 70) | (df['Stochastic_K'] > 80),  # „Ç™„Éº„Éê„Éº„Éú„Éº„Éà
            (df['RSI_14'] < 30) | (df['Stochastic_K'] < 20),  # „Ç™„Éº„Éê„Éº„ÇΩ„Éº„É´
        ]
        choices = ['OVERBOUGHT', 'OVERSOLD']
        return pd.Series(np.select(conditions, choices, default='NEUTRAL'), index=df.index)
    
    def _determine_volatility_state(self, df: pd.DataFrame) -> pd.Series:
        """„Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£Áä∂ÊÖã„ÅÆÂà§ÂÆö"""
        atr_percentile = df['ATR_14'].rolling(window=50).rank(pct=True)
        conditions = [
            atr_percentile > 0.8,  # È´ò„Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£
            atr_percentile < 0.2,  # ‰Ωé„Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£
        ]
        choices = ['HIGH', 'LOW']
        return pd.Series(np.select(conditions, choices, default='NORMAL'), index=df.index)
    
    def _determine_volume_state(self, df: pd.DataFrame) -> pd.Series:
        """„Éú„É™„É•„Éº„É†Áä∂ÊÖã„ÅÆÂà§ÂÆö"""
        conditions = [
            df['Volume_Ratio'] > 1.5,  # È´ò„Éú„É™„É•„Éº„É†
            df['Volume_Ratio'] < 0.5,  # ‰Ωé„Éú„É™„É•„Éº„É†
        ]
        choices = ['HIGH', 'LOW']
        return pd.Series(np.select(conditions, choices, default='NORMAL'), index=df.index)
    
    # Ë£úÂä©„É°„ÇΩ„ÉÉ„Éâ
    def _calculate_trend_strength(self, df: pd.DataFrame, periods: List[int]) -> pd.Series:
        """„Éà„É¨„É≥„ÉâÂº∑Â∫¶„ÅÆË®àÁÆó"""
        # Ë§áÊï∞ÊúüÈñì„ÅÆEMA„ÅÆÂÇæ„Åç„ÇíË®àÁÆó
        trend_scores = []
        for period in periods:
            ema_col = f'EMA_{period}'
            if ema_col in df.columns:
                slope = df[ema_col].diff(5)  # 5ÊúüÈñì„ÅÆÂ§âÂåñ
                trend_scores.append(slope)
        
        if trend_scores:
            # Âπ≥Âùá„Éà„É¨„É≥„ÉâÂº∑Â∫¶
            return pd.Series(np.mean(trend_scores, axis=0), index=df.index)
        else:
            return pd.Series(0, index=df.index)
    
    def _calculate_trend_consistency(self, df: pd.DataFrame) -> pd.Series:
        """„Éà„É¨„É≥„Éâ‰∏ÄË≤´ÊÄß„ÅÆË®àÁÆó"""
        # EMAÈñì„ÅÆ‰∏ÄË≤´ÊÄß„ÇíË®àÁÆó
        ema_21_slope = df['EMA_21'].diff(5)
        ema_55_slope = df['EMA_55'].diff(5)
        ema_200_slope = df['EMA_200'].diff(5)
        
        # Á¨¶Âè∑„ÅÆ‰∏ÄËá¥Â∫¶„ÇíË®àÁÆó
        consistency = (
            (ema_21_slope * ema_55_slope > 0).astype(int) +
            (ema_21_slope * ema_200_slope > 0).astype(int) +
            (ema_55_slope * ema_200_slope > 0).astype(int)
        ) / 3
        
        return consistency
    
    def _identify_entry_zones(self, df: pd.DataFrame) -> pd.Series:
        """„Ç®„É≥„Éà„É™„Éº„Çæ„Éº„É≥„ÅÆÁâπÂÆö"""
        # „Çµ„Éù„Éº„Éà„Éª„É¨„Ç∏„Çπ„Çø„É≥„Çπ„É¨„Éô„É´„Å®„ÅÆÈñ¢‰øÇ
        conditions = [
            df['close'] < df['BB_Lower'],  # Â£≤„Çä„Çæ„Éº„É≥
            df['close'] > df['BB_Upper'],  # Ë≤∑„ÅÑ„Çæ„Éº„É≥
        ]
        choices = ['SELL_ZONE', 'BUY_ZONE']
        return pd.Series(np.select(conditions, choices, default='NEUTRAL'), index=df.index)
    
    def _calculate_support_level(self, df: pd.DataFrame) -> pd.Series:
        """„Çµ„Éù„Éº„Éà„É¨„Éô„É´„ÅÆË®àÁÆó"""
        # ÈÅéÂéª20ÊúüÈñì„ÅÆÊúÄÂÆâÂÄ§
        return df['low'].rolling(window=20).min()
    
    def _calculate_resistance_level(self, df: pd.DataFrame) -> pd.Series:
        """„É¨„Ç∏„Çπ„Çø„É≥„Çπ„É¨„Éô„É´„ÅÆË®àÁÆó"""
        # ÈÅéÂéª20ÊúüÈñì„ÅÆÊúÄÈ´òÂÄ§
        return df['high'].rolling(window=20).max()
    
    def _identify_entry_timing(self, df: pd.DataFrame) -> pd.Series:
        """„Ç®„É≥„Éà„É™„Éº„Çø„Ç§„Éü„É≥„Ç∞„ÅÆÁâπÂÆö"""
        # RSI„Å®Stochastic„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ
        conditions = [
            (df['RSI_14'] < 30) & (df['Stochastic_K'] < 20),  # Ë≤∑„ÅÑ„Çø„Ç§„Éü„É≥„Ç∞
            (df['RSI_14'] > 70) & (df['Stochastic_K'] > 80),  # Â£≤„Çä„Çø„Ç§„Éü„É≥„Ç∞
        ]
        choices = ['BUY_TIMING', 'SELL_TIMING']
        return pd.Series(np.select(conditions, choices, default='WAIT'), index=df.index)
    
    def _calculate_short_momentum(self, df: pd.DataFrame) -> pd.Series:
        """Áü≠Êúü„É¢„É°„É≥„Çø„É†„ÅÆË®àÁÆó"""
        # RSI_7„ÅÆÂ§âÂåñÁéá
        return df['RSI_7'].diff(3)
    
    def _calculate_trend_reinforcement_strength(self, df: pd.DataFrame) -> pd.Series:
        """„Éà„É¨„É≥„ÉâË£úÂº∑Âº∑Â∫¶„ÅÆË®àÁÆó"""
        # MACD„Å®EMA„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ
        macd_bullish = (df['MACD'] > df['MACD_Signal']) & (df['EMA_21'] > df['EMA_55'])
        macd_bearish = (df['MACD'] < df['MACD_Signal']) & (df['EMA_21'] < df['EMA_55'])
        
        conditions = [macd_bullish, macd_bearish]
        choices = [1, -1]
        return pd.Series(np.select(conditions, choices, default=0), index=df.index)
    
    def _check_counter_trend_conditions(self, df: pd.DataFrame) -> pd.Series:
        """ÈÄÜÂºµ„ÇäÊù°‰ª∂„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ"""
        # ‰∏ä‰ΩçË∂≥„ÅÆÂèçËª¢„Çµ„Ç§„É≥„ÅåÂøÖË¶Å
        # „Åì„Åì„Åß„ÅØÁ∞°ÊòìÁöÑ„Å™ÂÆüË£Ö
        rsi_oversold = df['RSI_14'] < 30
        rsi_overbought = df['RSI_14'] > 70
        
        conditions = [rsi_oversold, rsi_overbought]
        choices = ['COUNTER_BUY', 'COUNTER_SELL']
        return pd.Series(np.select(conditions, choices, default='NONE'), index=df.index)
    
    def _calculate_candle_analysis_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """„É≠„Éº„ÇΩ„ÇØË∂≥ÂàÜÊûêÊåáÊ®ô„ÅÆË®àÁÆó"""
        # „É≠„Éº„ÇΩ„ÇØË∂≥„ÅÆÂü∫Êú¨ÊÉÖÂ†±
        df['candle_body'] = abs(df['close'] - df['open'])
        df['candle_upper_shadow'] = df['high'] - np.maximum(df['open'], df['close'])
        df['candle_lower_shadow'] = np.minimum(df['open'], df['close']) - df['low']
        df['candle_bullish'] = df['close'] > df['open']
        df['candle_bearish'] = df['close'] < df['open']
        
        # Ââç„ÅÆ„É≠„Éº„ÇΩ„ÇØË∂≥„Å®„ÅÆÊØîËºÉ
        df['previous_candle_bullish'] = df['candle_bullish'].shift(1)
        df['previous_candle_bearish'] = df['candle_bearish'].shift(1)
        
        # „Ç®„É≥„Ç¨„É´„Éï„Ç£„É≥„Ç∞„Éë„Çø„Éº„É≥„ÅÆÂà§ÂÆö
        df['current_candle'] = df['close'] - df['open']
        df['previous_candle'] = df['current_candle'].shift(1)
        
        # „É≠„Éº„ÇΩ„ÇØË∂≥„ÅÆ„Çµ„Ç§„Ç∫ÂàÜÊûê
        df['candle_body_size'] = df['candle_body']
        df['average_body_size'] = df['candle_body'].rolling(window=20).mean()
        
        return df
    
    def get_analysis_summary(self, data: Dict[str, pd.DataFrame]) -> Dict:
        """ÂàÜÊûêÁµêÊûú„ÅÆ„Çµ„Éû„É™„Éº„ÇíÂèñÂæó"""
        summary = {}
        
        for timeframe, df in data.items():
            if df.empty:
                continue
            
            latest = df.iloc[-1]
            
            summary[timeframe] = {
                'trend_direction': latest.get('Trend_Direction', 'UNKNOWN'),
                'momentum_state': latest.get('Momentum_State', 'UNKNOWN'),
                'volatility_state': latest.get('Volatility_State', 'UNKNOWN'),
                'volume_state': latest.get('Volume_State', 'UNKNOWN'),
                'rsi_14': latest.get('RSI_14', 0),
                'atr_14': latest.get('ATR_14', 0),
                'ema_21': latest.get('EMA_21', 0),
                'close': latest.get('close', 0),
                'timestamp': latest.name if hasattr(latest, 'name') else None
            }
        
        return summary
