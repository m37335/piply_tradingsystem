# Discord ãƒœãƒƒãƒˆå®Ÿè£…è©³ç´°è¨­è¨ˆæ›¸

**æ—§ãƒ•ã‚¡ã‚¤ãƒ«å**: `å®Ÿè£…è©³ç´°è¨­è¨ˆæ›¸.md`  

## ğŸš€ å®Ÿè£…æ¦‚è¦

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ

```
discord_usdjpy_bot/
â”œâ”€â”€ main.py                    # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ settings.py           # è¨­å®šç®¡ç†
â”‚   â””â”€â”€ database.py           # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š
â”œâ”€â”€ bot/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ client.py             # Discord Bot Client
â”‚   â”œâ”€â”€ commands.py           # ã‚³ãƒãƒ³ãƒ‰ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
â”‚   â”œâ”€â”€ permissions.py        # æ¨©é™ç®¡ç†
â”‚   â””â”€â”€ responses.py          # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”Ÿæˆ
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ analysis_service.py   # åˆ†æã‚µãƒ¼ãƒ“ã‚¹
â”‚   â”œâ”€â”€ cache_service.py      # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µãƒ¼ãƒ“ã‚¹
â”‚   â”œâ”€â”€ rate_limit.py         # ãƒ¬ãƒ¼ãƒˆåˆ¶é™
â”‚   â””â”€â”€ discord_service.py    # Discordé…ä¿¡ã‚µãƒ¼ãƒ“ã‚¹
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ user.py               # ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¢ãƒ‡ãƒ«
â”‚   â”œâ”€â”€ analysis.py           # åˆ†æãƒ¢ãƒ‡ãƒ«
â”‚   â””â”€â”€ database.py           # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¢ãƒ‡ãƒ«
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ logger.py             # ãƒ­ã‚°æ©Ÿèƒ½
â”‚   â”œâ”€â”€ formatter.py          # ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ©Ÿèƒ½
â”‚   â””â”€â”€ validators.py         # ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
â””â”€â”€ tests/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ test_commands.py
    â”œâ”€â”€ test_analysis.py
    â””â”€â”€ test_permissions.py
```

## ğŸ”§ æ ¸å¿ƒå®Ÿè£…

### 1. Discord Bot Client å®Ÿè£…

#### main.py

```python
import asyncio
import discord
from discord.ext import commands
from config.settings import Settings
from bot.client import USDJPYBot
from utils.logger import setup_logger

async def main():
    # ãƒ­ã‚°è¨­å®š
    setup_logger()

    # è¨­å®šèª­ã¿è¾¼ã¿
    settings = Settings()

    # BotåˆæœŸåŒ–
    intents = discord.Intents.default()
    intents.message_content = True
    intents.members = True

    bot = USDJPYBot(
        command_prefix='!',
        intents=intents,
        settings=settings
    )

    # ã‚³ã‚°èª­ã¿è¾¼ã¿
    await bot.load_extension('bot.commands')
    await bot.load_extension('bot.permissions')

    # Botèµ·å‹•
    await bot.start(settings.DISCORD_TOKEN)

if __name__ == "__main__":
    asyncio.run(main())
```

#### bot/client.py

```python
import discord
from discord.ext import commands
from typing import Optional
from config.settings import Settings
from services.analysis_service import AnalysisService
from services.cache_service import CacheService
from services.rate_limit import RateLimiter

class USDJPYBot(commands.Bot):
    def __init__(self, settings: Settings, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.settings = settings
        self.analysis_service = AnalysisService()
        self.cache_service = CacheService()
        self.rate_limiter = RateLimiter()

    async def setup_hook(self):
        """Botèµ·å‹•æ™‚ã®åˆæœŸåŒ–å‡¦ç†"""
        await self.analysis_service.initialize()
        await self.cache_service.initialize()

    async def on_ready(self):
        """Botæº–å‚™å®Œäº†æ™‚ã®å‡¦ç†"""
        print(f'{self.user} ã¨ã—ã¦ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã—ãŸ')
        await self.change_presence(
            activity=discord.Activity(
                type=discord.ActivityType.watching,
                name="USD/JPY Analysis"
            )
        )

    async def on_message(self, message):
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡æ™‚ã®å‡¦ç†"""
        if message.author.bot:
            return

        # ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã‚³ãƒãƒ³ãƒ‰æ¤œå‡º
        if message.content.startswith('#'):
            await self.handle_hashtag_command(message)
        else:
            await self.process_commands(message)

    async def handle_hashtag_command(self, message):
        """ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã‚³ãƒãƒ³ãƒ‰å‡¦ç†"""
        from bot.commands import AnalysisCommands
        commands_handler = AnalysisCommands(self)
        await commands_handler.handle_hashtag_command(message)
```

### 2. ã‚³ãƒãƒ³ãƒ‰ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å®Ÿè£…

#### bot/commands.py

```python
import discord
from discord.ext import commands
import re
from typing import Dict, Any, Optional
from services.analysis_service import AnalysisService
from services.rate_limit import RateLimiter
from bot.permissions import PermissionManager
from bot.responses import ResponseFormatter

class AnalysisCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.analysis_service = bot.analysis_service
        self.rate_limiter = bot.rate_limiter
        self.permission_manager = PermissionManager()
        self.response_formatter = ResponseFormatter()

    @commands.Cog.listener()
    async def on_message(self, message):
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒªã‚¹ãƒŠãƒ¼"""
        if message.author.bot:
            return

        # ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã‚³ãƒãƒ³ãƒ‰æ¤œå‡º
        if message.content.startswith('#'):
            await self.handle_hashtag_command(message)

    async def handle_hashtag_command(self, message):
        """ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã‚³ãƒãƒ³ãƒ‰å‡¦ç†"""
        try:
            # ã‚³ãƒãƒ³ãƒ‰è§£æ
            command_data = self.parse_hashtag_command(message.content)
            if not command_data:
                return

            # æ¨©é™ãƒã‚§ãƒƒã‚¯
            if not await self.permission_manager.check_permission(
                message.author, command_data['command']
            ):
                await message.channel.send(
                    "âŒ ã“ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"
                )
                return

            # ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯
            if not await self.rate_limiter.check_limit(
                message.author.id, command_data['command']
            ):
                await message.channel.send(
                    "â° ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚"
                )
                return

            # åˆ†æå®Ÿè¡Œ
            await self.execute_analysis(message, command_data)

        except Exception as e:
            await message.channel.send(f"âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}")

    def parse_hashtag_command(self, content: str) -> Optional[Dict[str, Any]]:
        """ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã‚³ãƒãƒ³ãƒ‰è§£æ"""
        # ã‚³ãƒãƒ³ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³å®šç¾©
        patterns = {
            r'#usdjpy\s*(\w+)?\s*(\w+)?': {
                'command': 'usdjpy',
                'params': ['timeframe', 'detail']
            },
            r'#analyze\s*(\w+)?\s*(\w+)?\s*(\w+)?': {
                'command': 'analyze',
                'params': ['currency', 'timeframe', 'options']
            },
            r'#forecast\s*(\w+)?\s*(\w+)?': {
                'command': 'forecast',
                'params': ['period', 'confidence']
            },
            r'#stats': {
                'command': 'stats',
                'params': []
            },
            r'#help': {
                'command': 'help',
                'params': []
            }
        }

        for pattern, config in patterns.items():
            match = re.match(pattern, content, re.IGNORECASE)
            if match:
                params = {}
                for i, param_name in enumerate(config['params']):
                    if i + 1 < len(match.groups()) and match.group(i + 1):
                        params[param_name] = match.group(i + 1)

                return {
                    'command': config['command'],
                    'params': params
                }

        return None

    async def execute_analysis(self, message, command_data):
        """åˆ†æå®Ÿè¡Œ"""
        # å‡¦ç†ä¸­ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
        processing_msg = await message.channel.send(
            "ğŸ”„ åˆ†æã‚’å®Ÿè¡Œä¸­ã§ã™... ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚"
        )

        try:
            # åˆ†æå®Ÿè¡Œ
            result = await self.analysis_service.execute_analysis(
                command_data['command'],
                command_data['params'],
                message.author.id
            )

            # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”Ÿæˆ
            embed = self.response_formatter.create_analysis_embed(result)

            # çµæœé€ä¿¡
            await processing_msg.delete()
            await message.channel.send(embed=embed)

        except Exception as e:
            await processing_msg.delete()
            await message.channel.send(f"âŒ åˆ†æå®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}")
```

### 3. åˆ†æã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…

#### services/analysis_service.py

```python
import asyncio
from typing import Dict, Any, Optional
from services.cache_service import CacheService
from utils.logger import get_logger

logger = get_logger(__name__)

class AnalysisService:
    def __init__(self):
        self.cache_service = CacheService()
        self.correlation_analyzer = None
        self.technical_analyzer = None

    async def initialize(self):
        """åˆæœŸåŒ–å‡¦ç†"""
        # æ—¢å­˜ã®åˆ†æã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’çµ±åˆ
        from src.infrastructure.analysis.currency_correlation_analyzer import (
            CurrencyCorrelationAnalyzer
        )
        from src.infrastructure.analysis.technical_indicators import (
            TechnicalIndicatorsAnalyzer
        )

        self.correlation_analyzer = CurrencyCorrelationAnalyzer()
        self.technical_analyzer = TechnicalIndicatorsAnalyzer()

    async def execute_analysis(
        self,
        command: str,
        params: Dict[str, Any],
        user_id: str
    ) -> Dict[str, Any]:
        """åˆ†æå®Ÿè¡Œ"""
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ç”Ÿæˆ
        cache_key = self._generate_cache_key(command, params)

        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
        cached_result = await self.cache_service.get_analysis(cache_key)
        if cached_result:
            logger.info(f"Cache hit for key: {cache_key}")
            return cached_result

        # åˆ†æå®Ÿè¡Œ
        if command == 'usdjpy':
            result = await self._execute_usdjpy_analysis(params)
        elif command == 'analyze':
            result = await self._execute_detailed_analysis(params)
        elif command == 'forecast':
            result = await self._execute_forecast_analysis(params)
        else:
            raise ValueError(f"Unknown command: {command}")

        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜
        await self.cache_service.cache_analysis(cache_key, result, ttl=300)

        return result

    async def _execute_usdjpy_analysis(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """USD/JPYåŸºæœ¬åˆ†æ"""
        # é€šè²¨ç›¸é–¢åˆ†æ
        correlation_data = await self.correlation_analyzer.perform_integrated_analysis()

        # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æ
        timeframe = params.get('timeframe', '1h')
        technical_data = await self._get_technical_indicators('USD/JPY', timeframe)

        # AIåˆ†æç”Ÿæˆ
        ai_analysis = await self._generate_ai_analysis(correlation_data, technical_data)

        return {
            'type': 'usdjpy_analysis',
            'correlation_data': correlation_data,
            'technical_data': technical_data,
            'ai_analysis': ai_analysis,
            'timestamp': asyncio.get_event_loop().time()
        }

    async def _execute_detailed_analysis(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """è©³ç´°åˆ†æ"""
        currency = params.get('currency', 'USDJPY')
        timeframe = params.get('timeframe', '1h')

        # è©³ç´°ãªåˆ†æã‚’å®Ÿè¡Œ
        result = await self._execute_usdjpy_analysis(params)
        result['type'] = 'detailed_analysis'
        result['currency'] = currency

        return result

    async def _execute_forecast_analysis(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """äºˆæ¸¬åˆ†æ"""
        period = params.get('period', '1d')
        confidence = params.get('confidence', 'medium')

        # äºˆæ¸¬åˆ†æã‚’å®Ÿè¡Œ
        result = await self._execute_usdjpy_analysis(params)
        result['type'] = 'forecast_analysis'
        result['forecast_period'] = period
        result['confidence_level'] = confidence

        return result

    async def _get_technical_indicators(self, currency_pair: str, timeframe: str):
        """ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™å–å¾—"""
        # æ—¢å­˜ã®ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†ææ©Ÿèƒ½ã‚’çµ±åˆ
        from scripts.cron.integrated_ai_discord import IntegratedAIDiscordReporter

        reporter = IntegratedAIDiscordReporter()
        await reporter.initialize_optimization_components()

        return await reporter._fetch_technical_indicators(currency_pair)

    async def _generate_ai_analysis(self, correlation_data: Dict, technical_data: Dict):
        """AIåˆ†æç”Ÿæˆ"""
        # æ—¢å­˜ã®AIåˆ†ææ©Ÿèƒ½ã‚’çµ±åˆ
        from scripts.cron.integrated_ai_discord import IntegratedAIDiscordReporter

        reporter = IntegratedAIDiscordReporter()
        return await reporter.generate_integrated_analysis(correlation_data, technical_data)

    def _generate_cache_key(self, command: str, params: Dict[str, Any]) -> str:
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ç”Ÿæˆ"""
        param_str = "_".join([f"{k}_{v}" for k, v in sorted(params.items())])
        return f"{command}_{param_str}"
```

### 4. ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼å®Ÿè£…

#### bot/responses.py

```python
import discord
from typing import Dict, Any
from datetime import datetime
import pytz

class ResponseFormatter:
    def __init__(self):
        self.jst = pytz.timezone("Asia/Tokyo")

    def create_analysis_embed(self, result: Dict[str, Any]) -> discord.Embed:
        """åˆ†æçµæœã®Embedä½œæˆ"""
        analysis_type = result.get('type', 'unknown')

        if analysis_type == 'usdjpy_analysis':
            return self._create_usdjpy_embed(result)
        elif analysis_type == 'detailed_analysis':
            return self._create_detailed_embed(result)
        elif analysis_type == 'forecast_analysis':
            return self._create_forecast_embed(result)
        else:
            return self._create_error_embed("Unknown analysis type")

    def _create_usdjpy_embed(self, result: Dict[str, Any]) -> discord.Embed:
        """USD/JPYåˆ†æEmbedä½œæˆ"""
        correlation_data = result.get('correlation_data', {})
        ai_analysis = result.get('ai_analysis', '')

        # åŸºæœ¬æƒ…å ±å–å¾—
        usdjpy_forecast = correlation_data.get('usdjpy_forecast', {})
        current_rate = usdjpy_forecast.get('current_rate', 0)
        strategy_bias = usdjpy_forecast.get('strategy_bias', 'NEUTRAL')
        forecast_confidence = usdjpy_forecast.get('forecast_confidence', 0)

        # è‰²è¨­å®š
        color = self._get_strategy_color(strategy_bias)

        # Embedä½œæˆ
        embed = discord.Embed(
            title="ğŸ¯ USD/JPY AI Analysis",
            description="é€šè²¨ç›¸é–¢æ€§ã‚’æ´»ç”¨ã—ãŸAIçµ±åˆåˆ†æ",
            color=color,
            timestamp=datetime.now(self.jst)
        )

        # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ 
        embed.add_field(
            name="ğŸ“Š Current Rate",
            value=f"**{current_rate:.4f}**",
            inline=True
        )

        embed.add_field(
            name="ğŸ¯ Strategy",
            value=f"**{strategy_bias}** ({forecast_confidence}%)",
            inline=True
        )

        embed.add_field(
            name="ğŸ“ˆ Analysis",
            value=ai_analysis[:1000] + "..." if len(ai_analysis) > 1000 else ai_analysis,
            inline=False
        )

        embed.set_footer(text="USD/JPY AI Analysis Bot")

        return embed

    def _create_detailed_embed(self, result: Dict[str, Any]) -> discord.Embed:
        """è©³ç´°åˆ†æEmbedä½œæˆ"""
        embed = self._create_usdjpy_embed(result)
        embed.title = "ğŸ” Detailed USD/JPY Analysis"

        # è©³ç´°æƒ…å ±ã‚’è¿½åŠ 
        technical_data = result.get('technical_data', {})
        if technical_data:
            tech_summary = self._format_technical_summary(technical_data)
            embed.add_field(
                name="ğŸ“Š Technical Summary",
                value=tech_summary,
                inline=False
            )

        return embed

    def _create_forecast_embed(self, result: Dict[str, Any]) -> discord.Embed:
        """äºˆæ¸¬åˆ†æEmbedä½œæˆ"""
        embed = self._create_usdjpy_embed(result)
        embed.title = "ğŸ”® USD/JPY Forecast Analysis"

        # äºˆæ¸¬æƒ…å ±ã‚’è¿½åŠ 
        period = result.get('forecast_period', '1d')
        confidence = result.get('confidence_level', 'medium')

        embed.add_field(
            name="â° Forecast Period",
            value=f"**{period}**",
            inline=True
        )

        embed.add_field(
            name="ğŸ¯ Confidence Level",
            value=f"**{confidence.upper()}**",
            inline=True
        )

        return embed

    def _create_error_embed(self, error_message: str) -> discord.Embed:
        """ã‚¨ãƒ©ãƒ¼Embedä½œæˆ"""
        embed = discord.Embed(
            title="âŒ Analysis Error",
            description=error_message,
            color=0xFF0000,
            timestamp=datetime.now(self.jst)
        )

        embed.set_footer(text="USD/JPY AI Analysis Bot")
        return embed

    def _get_strategy_color(self, strategy_bias: str) -> int:
        """æˆ¦ç•¥ãƒã‚¤ã‚¢ã‚¹ã«åŸºã¥ãè‰²å–å¾—"""
        color_map = {
            'LONG': 0x00FF00,    # ç·‘è‰²
            'SHORT': 0xFF0000,   # èµ¤è‰²
            'NEUTRAL': 0xFFFF00  # é»„è‰²
        }
        return color_map.get(strategy_bias, 0x808080)  # ã‚°ãƒ¬ãƒ¼

    def _format_technical_summary(self, technical_data: Dict[str, Any]) -> str:
        """ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚µãƒãƒªãƒ¼ä½œæˆ"""
        summary = []

        for timeframe in ['D1', 'H4', 'H1', 'M5']:
            if f"{timeframe}_RSI_SHORT" in technical_data:
                rsi_data = technical_data[f"{timeframe}_RSI_SHORT"]
                rsi_val = rsi_data.get('current_value', 'N/A')
                if isinstance(rsi_val, (int, float)):
                    summary.append(f"{timeframe}: RSI={rsi_val:.1f}")

        return " | ".join(summary) if summary else "No technical data available"
```

### 5. ãƒ¬ãƒ¼ãƒˆåˆ¶é™å®Ÿè£…

#### services/rate_limit.py

```python
import asyncio
import time
from typing import Dict, Any
from collections import defaultdict
import redis
from config.settings import Settings

class RateLimiter:
    def __init__(self):
        self.settings = Settings()
        self.redis_client = None
        self.memory_limits = defaultdict(list)

    async def initialize(self):
        """åˆæœŸåŒ–"""
        try:
            self.redis_client = redis.Redis.from_url(self.settings.REDIS_URL)
            await self.redis_client.ping()
        except Exception as e:
            print(f"Redis connection failed, using memory storage: {e}")
            self.redis_client = None

    async def check_limit(self, user_id: str, command: str) -> bool:
        """ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯"""
        # åˆ¶é™è¨­å®š
        limits = {
            'usdjpy': {'calls': 1, 'window': 60},    # 1åˆ†é–“ã«1å›
            'analyze': {'calls': 3, 'window': 60},   # 1åˆ†é–“ã«3å›
            'forecast': {'calls': 2, 'window': 60},  # 1åˆ†é–“ã«2å›
            'stats': {'calls': 10, 'window': 60},    # 1åˆ†é–“ã«10å›
            'help': {'calls': 5, 'window': 60}       # 1åˆ†é–“ã«5å›
        }

        limit_config = limits.get(command, {'calls': 1, 'window': 60})

        if self.redis_client:
            return await self._check_redis_limit(user_id, command, limit_config)
        else:
            return self._check_memory_limit(user_id, command, limit_config)

    async def _check_redis_limit(self, user_id: str, command: str, limit_config: Dict[str, Any]) -> bool:
        """Redisãƒ™ãƒ¼ã‚¹ã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯"""
        key = f"rate_limit:{user_id}:{command}"
        current_time = int(time.time())
        window = limit_config['window']
        max_calls = limit_config['calls']

        # å¤ã„ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤
        await self.redis_client.zremrangebyscore(key, 0, current_time - window)

        # ç¾åœ¨ã®å‘¼ã³å‡ºã—æ•°ã‚’å–å¾—
        current_calls = await self.redis_client.zcard(key)

        if current_calls >= max_calls:
            return False

        # æ–°ã—ã„å‘¼ã³å‡ºã—ã‚’è¨˜éŒ²
        await self.redis_client.zadd(key, {str(current_time): current_time})
        await self.redis_client.expire(key, window)

        return True

    def _check_memory_limit(self, user_id: str, command: str, limit_config: Dict[str, Any]) -> bool:
        """ãƒ¡ãƒ¢ãƒªãƒ™ãƒ¼ã‚¹ã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯"""
        key = f"{user_id}:{command}"
        current_time = time.time()
        window = limit_config['window']
        max_calls = limit_config['calls']

        # å¤ã„ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤
        self.memory_limits[key] = [
            timestamp for timestamp in self.memory_limits[key]
            if current_time - timestamp < window
        ]

        # ç¾åœ¨ã®å‘¼ã³å‡ºã—æ•°ã‚’ãƒã‚§ãƒƒã‚¯
        if len(self.memory_limits[key]) >= max_calls:
            return False

        # æ–°ã—ã„å‘¼ã³å‡ºã—ã‚’è¨˜éŒ²
        self.memory_limits[key].append(current_time)

        return True
```

## ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆè¨­å®š

### requirements.txt

```
discord.py==2.3.2
fastapi==0.104.1
uvicorn==0.24.0
redis==5.0.1
sqlalchemy==2.0.23
psycopg2-binary==2.9.9
pydantic==2.5.0
python-dotenv==1.0.0
pytz==2023.3
httpx==0.25.2
rich==13.7.0
```

### Dockerfile

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ”ãƒ¼
COPY . .

# ç’°å¢ƒå¤‰æ•°è¨­å®š
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# å®Ÿè¡Œ
CMD ["python", "main.py"]
```

### docker-compose.yml

```yaml
version: "3.8"

services:
  discord-bot:
    build: .
    environment:
      - DISCORD_TOKEN=${DISCORD_TOKEN}
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      - postgres
      - redis
    restart: unless-stopped

  postgres:
    image: postgres:13
    environment:
      - POSTGRES_DB=usdjpy_bot
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

## ğŸ“Š ç›£è¦–ãƒ»ãƒ­ã‚°è¨­å®š

### ãƒ­ã‚°è¨­å®š

```python
# utils/logger.py
import logging
import sys
from logging.handlers import RotatingFileHandler

def setup_logger():
    """ãƒ­ã‚°è¨­å®š"""
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

    # ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    file_handler = RotatingFileHandler(
        'discord_bot.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setFormatter(formatter)

    # ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)

    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆå®Ÿè£…

### ãƒ†ã‚¹ãƒˆä¾‹

```python
# tests/test_commands.py
import pytest
from unittest.mock import Mock, AsyncMock
from bot.commands import AnalysisCommands

@pytest.fixture
def mock_bot():
    bot = Mock()
    bot.analysis_service = AsyncMock()
    bot.rate_limiter = AsyncMock()
    return bot

@pytest.fixture
def commands_handler(mock_bot):
    return AnalysisCommands(mock_bot)

@pytest.mark.asyncio
async def test_parse_usdjpy_command(commands_handler):
    """USD/JPYã‚³ãƒãƒ³ãƒ‰è§£æãƒ†ã‚¹ãƒˆ"""
    content = "#usdjpy 1h basic"
    result = commands_handler.parse_hashtag_command(content)

    assert result is not None
    assert result['command'] == 'usdjpy'
    assert result['params']['timeframe'] == '1h'
    assert result['params']['detail'] == 'basic'

@pytest.mark.asyncio
async def test_rate_limit_check(commands_handler):
    """ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ†ã‚¹ãƒˆ"""
    commands_handler.bot.rate_limiter.check_limit.return_value = False

    message = Mock()
    message.author.id = "123456"
    message.channel.send = AsyncMock()

    await commands_handler.handle_hashtag_command(message)

    message.channel.send.assert_called_with(
        "â° ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚"
    )
```

---

**ä½œæˆæ—¥**: 2025 å¹´ 8 æœˆ 12 æ—¥
**ä½œæˆè€…**: AI Assistant
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0
