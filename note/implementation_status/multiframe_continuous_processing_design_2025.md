# ğŸ”„ ãƒãƒ«ãƒã‚¿ã‚¤ãƒ ãƒ•ãƒ¬ãƒ¼ãƒ ç¶™ç¶šå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆæ›¸

**ä½œæˆæ—¥**: 2025 å¹´ 8 æœˆ 10 æ—¥
**ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**: Exchange Analytics System
**è¨­è¨ˆå¯¾è±¡**: 5 åˆ†è¶³ãƒ‡ãƒ¼ã‚¿å–å¾—å¾Œã®è‡ªå‹•é›†è¨ˆã¨ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—ã®ç¶™ç¶šå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ 

## ğŸ¯ è¨­è¨ˆç›®çš„

### å•é¡Œè§£æ±º

- **åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ã®åˆ¶ç´„**: 5 åˆ†è¶³ã ã‘ã§ã¯ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ãŒè¨ˆç®—ã§ããªã„å•é¡Œã®è§£æ±º
- **API åˆ¶é™å¯¾å¿œ**: è¤‡æ•°æ™‚é–“è»¸ã®åŒæ™‚å–å¾—ãŒã§ããªã„åˆ¶ç´„ã®å›é¿
- **ç¶™ç¶šçš„ãƒ•ãƒ­ãƒ¼å®Ÿç¾**: 5 åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ã®ã¿ã§ç¶™ç¶šçš„ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—ãƒ•ãƒ­ãƒ¼ã®ç¢ºç«‹
- **ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºçµ±åˆ**: ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚’æ´»ç”¨ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ ã®çµ±åˆ

### ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦

**åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—**: å…¨æ™‚é–“è»¸ï¼ˆ5 åˆ†è¶³ã€1 æ™‚é–“è¶³ã€4 æ™‚é–“è¶³ã€æ—¥è¶³ï¼‰ã®å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ‹¬å–å¾—ã—ã€ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚’è¨ˆç®—
**ç¶™ç¶šå‡¦ç†**: 5 åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—å¾Œã€è‡ªå‹•çš„ã« 1 æ™‚é–“è¶³ãƒ»4 æ™‚é–“è¶³ã«é›†è¨ˆã—ã€å„æ™‚é–“è»¸ã§ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚’è¨ˆç®—ã—ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºã‚’è¡Œã†çµ±åˆã‚·ã‚¹ãƒ†ãƒ 

## ğŸ—ï¸ ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ•ãƒ­ãƒ¼

```
åˆå›å®Ÿè¡Œ â†’ å…¨æ™‚é–“è»¸ãƒ‡ãƒ¼ã‚¿å–å¾— â†’ ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®— â†’ ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º â†’ ã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†
    â†“              â†“              â†“              â†“
 5åˆ†è¶³å–å¾—    â†’ 1æ™‚é–“è¶³å–å¾—   â†’ RSI/MACD/BB   â†’ 6ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º â†’ ç¶™ç¶šå‡¦ç†é–‹å§‹
    â†“              â†“              â†“              â†“
 4æ™‚é–“è¶³å–å¾—   â†’ æ—¥è¶³å–å¾—      â†’ æŒ‡æ¨™ä¿å­˜      â†’ æ¤œå‡ºçµæœä¿å­˜   â†’ ç›£è¦–é–‹å§‹
```

### ç¶™ç¶šå‡¦ç†ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

```
5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿å–å¾— â†’ è‡ªå‹•é›†è¨ˆ â†’ ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®— â†’ ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º â†’ é€šçŸ¥
     â†“              â†“              â†“              â†“
  5åˆ†è¶³ä¿å­˜    â†’ 1æ™‚é–“è¶³é›†è¨ˆ   â†’ RSI/MACD/BB   â†’ 6ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º â†’ Discord
     â†“              â†“              â†“              â†“
  ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹   â†’ 4æ™‚é–“è¶³é›†è¨ˆ   â†’ æŒ‡æ¨™ä¿å­˜      â†’ æ¤œå‡ºçµæœä¿å­˜   â†’ é€šçŸ¥é€ä¿¡
```

### ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæ§‹æˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Continuous Processing Pipeline                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  DataFetcherService    â”‚  TimeframeAggregatorService        â”‚
â”‚  (5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿å–å¾—)      â”‚  (è‡ªå‹•é›†è¨ˆå‡¦ç†)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  TechnicalIndicatorService  â”‚  PatternDetectionService      â”‚
â”‚  (ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—)        â”‚  (ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  NotificationService   â”‚  MonitoringService                 â”‚
â”‚  (é€šçŸ¥å‡¦ç†)            â”‚  (ç›£è¦–ãƒ»ãƒ­ã‚°)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ ä¾å­˜é–¢ä¿‚ã¨æ—¢å­˜ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

### æ—¢å­˜ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆå†åˆ©ç”¨ï¼‰

#### 1. ãƒ‡ãƒ¼ã‚¿å–å¾—é–¢é€£

```python
# æ—¢å­˜ã‚¯ãƒ©ã‚¹: 5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿å–å¾—
src/infrastructure/database/services/multi_timeframe_data_fetcher_service.py
â”œâ”€â”€ MultiTimeframeDataFetcherService
â”‚   â”œâ”€â”€ fetch_timeframe_data(timeframe: str) -> Optional[PriceDataModel]
â”‚   â””â”€â”€ fetch_all_timeframes() -> Dict[str, Optional[PriceDataModel]]

# æ—¢å­˜ã‚¯ãƒ©ã‚¹: å¤–éƒ¨API
src/infrastructure/external_apis/yahoo_finance_client.py
â”œâ”€â”€ YahooFinanceClient
â”‚   â”œâ”€â”€ get_current_rate(currency_pair: str) -> Optional[Dict]
â”‚   â””â”€â”€ get_historical_data(currency_pair, period, interval) -> Optional[pd.DataFrame]
```

#### 2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é–¢é€£

```python
# æ—¢å­˜ãƒ¢ãƒ‡ãƒ«: ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿
src/infrastructure/database/models/price_data_model.py
â”œâ”€â”€ PriceDataModel
â”‚   â”œâ”€â”€ currency_pair: str
â”‚   â”œâ”€â”€ timestamp: datetime
â”‚   â”œâ”€â”€ open_price, high_price, low_price, close_price: Decimal
â”‚   â””â”€â”€ volume: BigInteger

# æ—¢å­˜ãƒ¢ãƒ‡ãƒ«: ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™
src/infrastructure/database/models/technical_indicator_model.py
â”œâ”€â”€ TechnicalIndicatorModel
â”‚   â”œâ”€â”€ indicator_type: str (RSI, MACD, BB)
â”‚   â”œâ”€â”€ timeframe: str (5m, 1h, 4h, 1d)
â”‚   â”œâ”€â”€ value: Decimal
â”‚   â””â”€â”€ additional_data: JSON

# æ—¢å­˜ãƒ¢ãƒ‡ãƒ«: ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º
src/infrastructure/database/models/pattern_detection_model.py
â”œâ”€â”€ PatternDetectionModel
â”‚   â”œâ”€â”€ pattern_type: str
â”‚   â”œâ”€â”€ confidence_score: Decimal
â”‚   â”œâ”€â”€ direction: str (BUY/SELL)
â”‚   â””â”€â”€ detection_data: JSON
```

#### 3. ãƒªãƒã‚¸ãƒˆãƒªé–¢é€£

```python
# æ—¢å­˜ãƒªãƒã‚¸ãƒˆãƒª: ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿
src/infrastructure/database/repositories/price_data_repository_impl.py
â”œâ”€â”€ PriceDataRepositoryImpl
â”‚   â”œâ”€â”€ save(price_data: PriceDataModel) -> PriceDataModel
â”‚   â”œâ”€â”€ find_by_date_range(start, end, currency_pair) -> List[PriceDataModel]
â”‚   â””â”€â”€ find_latest(currency_pair, limit) -> List[PriceDataModel]

# æ—¢å­˜ãƒªãƒã‚¸ãƒˆãƒª: ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™
src/infrastructure/database/repositories/technical_indicator_repository_impl.py
â”œâ”€â”€ TechnicalIndicatorRepositoryImpl
â”‚   â”œâ”€â”€ save(indicator: TechnicalIndicatorModel) -> TechnicalIndicatorModel
â”‚   â”œâ”€â”€ find_latest_by_type(indicator_type, timeframe) -> List[TechnicalIndicatorModel]
â”‚   â””â”€â”€ find_by_date_range(start, end, indicator_type, timeframe) -> List[TechnicalIndicatorModel]

# æ—¢å­˜ãƒªãƒã‚¸ãƒˆãƒª: ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º
src/infrastructure/database/repositories/pattern_detection_repository_impl.py
â”œâ”€â”€ PatternDetectionRepositoryImpl
â”‚   â”œâ”€â”€ save(pattern: PatternDetectionModel) -> PatternDetectionModel
â”‚   â”œâ”€â”€ find_unnotified_patterns() -> List[PatternDetectionModel]
â”‚   â””â”€â”€ mark_notification_sent(pattern_id: int) -> bool
```

#### 4. åˆ†æé–¢é€£

```python
# æ—¢å­˜ã‚¯ãƒ©ã‚¹: ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—
src/infrastructure/analysis/technical_indicators.py
â”œâ”€â”€ TechnicalIndicatorsAnalyzer
â”‚   â”œâ”€â”€ calculate_rsi(data: pd.DataFrame, timeframe: str) -> Dict[str, Any]
â”‚   â”œâ”€â”€ calculate_macd(data: pd.DataFrame, timeframe: str) -> Dict[str, Any]
â”‚   â””â”€â”€ calculate_bollinger_bands(data: pd.DataFrame, timeframe: str) -> Dict[str, Any]

# æ—¢å­˜ã‚¯ãƒ©ã‚¹: ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºå™¨
src/infrastructure/analysis/pattern_detectors/
â”œâ”€â”€ breakout_detector.py
â”œâ”€â”€ trend_reversal_detector.py
â”œâ”€â”€ rsi_battle_detector.py
â”œâ”€â”€ pullback_detector.py
â”œâ”€â”€ divergence_detector.py
â””â”€â”€ composite_signal_detector.py
```

#### 5. é€šçŸ¥é–¢é€£

```python
# æ—¢å­˜ã‚¯ãƒ©ã‚¹: Discordé€šçŸ¥
src/infrastructure/messaging/discord_client.py
â”œâ”€â”€ DiscordClient
â”‚   â””â”€â”€ send_message(message: str) -> bool

# æ—¢å­˜ã‚¯ãƒ©ã‚¹: é€šçŸ¥ç®¡ç†
src/infrastructure/messaging/notification_manager.py
â”œâ”€â”€ NotificationManager
â”‚   â”œâ”€â”€ send_pattern_notification(pattern: PatternDetectionModel) -> bool
â”‚   â””â”€â”€ send_system_notification(message: str) -> bool
```

## ğŸ†• æ–°è¦ä½œæˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

### 1. åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚µãƒ¼ãƒ“ã‚¹

#### ãƒ•ã‚¡ã‚¤ãƒ«: `src/infrastructure/database/services/initial_data_loader_service.py`

```python
"""
åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚µãƒ¼ãƒ“ã‚¹

è²¬ä»»:
- å…¨æ™‚é–“è»¸ï¼ˆ5åˆ†è¶³ã€1æ™‚é–“è¶³ã€4æ™‚é–“è¶³ã€æ—¥è¶³ï¼‰ã®å±¥æ­´ãƒ‡ãƒ¼ã‚¿ä¸€æ‹¬å–å¾—
- åˆå›ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—
- åˆå›ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºå®Ÿè¡Œ
- ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ã®å®Œäº†ç¢ºèª

ç‰¹å¾´:
- APIåˆ¶é™ã‚’è€ƒæ…®ã—ãŸæ®µéšçš„ãƒ‡ãƒ¼ã‚¿å–å¾—
- é‡è¤‡ãƒ‡ãƒ¼ã‚¿ã®é˜²æ­¢
- åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- åˆæœŸåŒ–é€²æ—ã®ç›£è¦–
"""

class InitialDataLoaderService:
    """
    åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚µãƒ¼ãƒ“ã‚¹

    è²¬ä»»:
    - å…¨æ™‚é–“è»¸ï¼ˆ5åˆ†è¶³ã€1æ™‚é–“è¶³ã€4æ™‚é–“è¶³ã€æ—¥è¶³ï¼‰ã®å±¥æ­´ãƒ‡ãƒ¼ã‚¿ä¸€æ‹¬å–å¾—
    - åˆå›ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—
    - åˆå›ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºå®Ÿè¡Œ
    - ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ã®å®Œäº†ç¢ºèª
    """

    def __init__(self, session: AsyncSession):
        self.session = session
        self.yahoo_client = YahooFinanceClient()
        self.price_repo = PriceDataRepositoryImpl(session)
        self.indicator_service = MultiTimeframeTechnicalIndicatorService(session)
        self.pattern_service = EfficientPatternDetectionService(session)

        # åˆå›å–å¾—è¨­å®š
        self.initial_load_config = {
            "5m": {"period": "7d", "interval": "5m", "description": "5åˆ†è¶³"},
            "1h": {"period": "30d", "interval": "1h", "description": "1æ™‚é–“è¶³"},
            "4h": {"period": "60d", "interval": "4h", "description": "4æ™‚é–“è¶³"},
            "1d": {"period": "365d", "interval": "1d", "description": "æ—¥è¶³"}
        }

        self.currency_pair = "USD/JPY"
        self.max_retries = 3
        self.retry_delay = 5  # ç§’

    async def load_all_initial_data(self) -> Dict[str, Any]:
        """
        å…¨æ™‚é–“è»¸ã®åˆå›ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—

        Returns:
            Dict[str, Any]: å„æ™‚é–“è»¸ã®å–å¾—çµæœ
        """
        # å®Ÿè£…è©³ç´°...

    async def load_timeframe_data(self, timeframe: str) -> int:
        """
        ç‰¹å®šæ™‚é–“è»¸ã®åˆå›ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—

        Args:
            timeframe: æ™‚é–“è»¸ï¼ˆ5m, 1h, 4h, 1dï¼‰

        Returns:
            int: å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ä»¶æ•°
        """
        # å®Ÿè£…è©³ç´°...

    async def calculate_initial_indicators(self) -> Dict[str, int]:
        """
        åˆå›ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚’è¨ˆç®—

        Returns:
            Dict[str, int]: å„æ™‚é–“è»¸ã®æŒ‡æ¨™è¨ˆç®—ä»¶æ•°
        """
        # å®Ÿè£…è©³ç´°...

    async def detect_initial_patterns(self) -> Dict[str, int]:
        """
        åˆå›ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºã‚’å®Ÿè¡Œ

        Returns:
            Dict[str, int]: æ¤œå‡ºã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³æ•°
        """
        # å®Ÿè£…è©³ç´°...

    async def verify_initialization(self) -> bool:
        """
        åˆæœŸåŒ–ã®å®Œäº†ã‚’ç¢ºèª

        Returns:
            bool: åˆæœŸåŒ–å®Œäº†ãƒ•ãƒ©ã‚°
        """
        # å®Ÿè£…è©³ç´°...
```

### 2. ç¶™ç¶šå‡¦ç†çµ±åˆã‚µãƒ¼ãƒ“ã‚¹

#### ãƒ•ã‚¡ã‚¤ãƒ«: `src/infrastructure/database/services/continuous_processing_service.py`

```python
"""
ç¶™ç¶šå‡¦ç†çµ±åˆã‚µãƒ¼ãƒ“ã‚¹

è²¬ä»»:
- 5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿å–å¾—å¾Œã®è‡ªå‹•é›†è¨ˆå‡¦ç†
- ãƒãƒ«ãƒã‚¿ã‚¤ãƒ ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—
- ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºã®çµ±åˆå®Ÿè¡Œ
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½

ç‰¹å¾´:
- å®Œå…¨è‡ªå‹•åŒ–ã•ã‚ŒãŸç¶™ç¶šå‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
- å„ã‚¹ãƒ†ãƒƒãƒ—ã®ä¾å­˜é–¢ä¿‚ç®¡ç†
- åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
"""

class ContinuousProcessingService:
    """
    ç¶™ç¶šå‡¦ç†çµ±åˆã‚µãƒ¼ãƒ“ã‚¹

    è²¬ä»»:
    - 5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿å–å¾—å¾Œã®è‡ªå‹•é›†è¨ˆå‡¦ç†
    - ãƒãƒ«ãƒã‚¿ã‚¤ãƒ ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—
    - ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºã®çµ±åˆå®Ÿè¡Œ
    - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½
    """

    def __init__(self, session: AsyncSession):
        # ä¾å­˜ã‚µãƒ¼ãƒ“ã‚¹åˆæœŸåŒ–
        self.timeframe_aggregator = TimeframeAggregatorService(session)
        self.technical_indicator_service = MultiTimeframeTechnicalIndicatorService(session)
        self.pattern_detection_service = EfficientPatternDetectionService(session)
        self.notification_service = NotificationManager()

        # è¨­å®š
        self.currency_pair = "USD/JPY"
        self.timeframes = ["5m", "1h", "4h"]
        self.retry_attempts = 3
        self.retry_delay = 30  # ç§’

    async def process_5m_data(self, price_data: PriceDataModel) -> Dict[str, Any]:
        """
        5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ã®ç¶™ç¶šå‡¦ç†ã‚’å®Ÿè¡Œ

        Args:
            price_data: å–å¾—ã•ã‚ŒãŸ5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿

        Returns:
            Dict[str, Any]: å‡¦ç†çµæœã®çµ±è¨ˆæƒ…å ±
        """
        # å®Ÿè£…è©³ç´°...

    async def aggregate_timeframes(self) -> Dict[str, int]:
        """
        æ™‚é–“è»¸ã®è‡ªå‹•é›†è¨ˆã‚’å®Ÿè¡Œ

        Returns:
            Dict[str, int]: å„æ™‚é–“è»¸ã®é›†è¨ˆä»¶æ•°
        """
        # å®Ÿè£…è©³ç´°...

    async def calculate_all_indicators(self) -> Dict[str, int]:
        """
        å…¨æ™‚é–“è»¸ã®ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚’è¨ˆç®—

        Returns:
            Dict[str, int]: å„æ™‚é–“è»¸ã®æŒ‡æ¨™è¨ˆç®—ä»¶æ•°
        """
        # å®Ÿè£…è©³ç´°...

    async def detect_patterns(self) -> Dict[str, int]:
        """
        ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºã‚’å®Ÿè¡Œ

        Returns:
            Dict[str, int]: æ¤œå‡ºã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³æ•°
        """
        # å®Ÿè£…è©³ç´°...
```

### 2. æ™‚é–“è»¸è‡ªå‹•é›†è¨ˆã‚µãƒ¼ãƒ“ã‚¹

#### ãƒ•ã‚¡ã‚¤ãƒ«: `src/infrastructure/database/services/timeframe_aggregator_service.py`

```python
"""
æ™‚é–“è»¸è‡ªå‹•é›†è¨ˆã‚µãƒ¼ãƒ“ã‚¹

è²¬ä»»:
- 5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰1æ™‚é–“è¶³ãƒ»4æ™‚é–“è¶³ã¸ã®è‡ªå‹•é›†è¨ˆ
- é›†è¨ˆãƒ‡ãƒ¼ã‚¿ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¿å­˜
- é‡è¤‡ãƒ‡ãƒ¼ã‚¿ã®é˜²æ­¢
- é›†è¨ˆå“è³ªã®ç›£è¦–

ç‰¹å¾´:
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é›†è¨ˆå‡¦ç†
- åŠ¹ç‡çš„ãªãƒ¡ãƒ¢ãƒªä½¿ç”¨
- ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ä¿è¨¼
- è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
"""

class TimeframeAggregatorService:
    """
    æ™‚é–“è»¸è‡ªå‹•é›†è¨ˆã‚µãƒ¼ãƒ“ã‚¹

    è²¬ä»»:
    - 5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰1æ™‚é–“è¶³ãƒ»4æ™‚é–“è¶³ã¸ã®è‡ªå‹•é›†è¨ˆ
    - é›†è¨ˆãƒ‡ãƒ¼ã‚¿ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¿å­˜
    - é‡è¤‡ãƒ‡ãƒ¼ã‚¿ã®é˜²æ­¢
    - é›†è¨ˆå“è³ªã®ç›£è¦–
    """

    def __init__(self, session: AsyncSession):
        self.session = session
        self.price_repo = PriceDataRepositoryImpl(session)
        self.currency_pair = "USD/JPY"

        # é›†è¨ˆè¨­å®š
        self.aggregation_rules = {
            "1h": {"minutes": 60, "description": "1æ™‚é–“è¶³"},
            "4h": {"minutes": 240, "description": "4æ™‚é–“è¶³"}
        }

    async def aggregate_1h_data(self) -> List[PriceDataModel]:
        """
        5åˆ†è¶³ã‹ã‚‰1æ™‚é–“è¶³ãƒ‡ãƒ¼ã‚¿ã‚’é›†è¨ˆ

        Returns:
            List[PriceDataModel]: é›†è¨ˆã•ã‚ŒãŸ1æ™‚é–“è¶³ãƒ‡ãƒ¼ã‚¿
        """
        # å®Ÿè£…è©³ç´°...

    async def aggregate_4h_data(self) -> List[PriceDataModel]:
        """
        5åˆ†è¶³ã‹ã‚‰4æ™‚é–“è¶³ãƒ‡ãƒ¼ã‚¿ã‚’é›†è¨ˆ

        Returns:
            List[PriceDataModel]: é›†è¨ˆã•ã‚ŒãŸ4æ™‚é–“è¶³ãƒ‡ãƒ¼ã‚¿
        """
        # å®Ÿè£…è©³ç´°...

    async def aggregate_all_timeframes(self) -> Dict[str, int]:
        """
        å…¨æ™‚é–“è»¸ã®é›†è¨ˆã‚’å®Ÿè¡Œ

        Returns:
            Dict[str, int]: å„æ™‚é–“è»¸ã®é›†è¨ˆä»¶æ•°
        """
        # å®Ÿè£…è©³ç´°...

    def _aggregate_timeframe_data(self, df: pd.DataFrame, timeframe: str) -> pd.DataFrame:
        """
        æŒ‡å®šæ™‚é–“è»¸ã«ãƒ‡ãƒ¼ã‚¿ã‚’é›†è¨ˆ

        Args:
            df: 5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ã®DataFrame
            timeframe: é›†è¨ˆæ™‚é–“è»¸ï¼ˆ1h, 4hï¼‰

        Returns:
            pd.DataFrame: é›†è¨ˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
        """
        # å®Ÿè£…è©³ç´°...
```

### 3. ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼

#### ãƒ•ã‚¡ã‚¤ãƒ«: `src/infrastructure/database/services/system_initialization_manager.py`

```python
"""
ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼

è²¬ä»»:
- åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ã¨ç¶™ç¶šå‡¦ç†ã®çµ±åˆç®¡ç†
- åˆæœŸåŒ–çŠ¶æ…‹ã®ç®¡ç†
- åˆå›å®Ÿè¡Œã¨ç¶™ç¶šå®Ÿè¡Œã®åˆ‡ã‚Šæ›¿ãˆ
- ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã®ç›£è¦–

ç‰¹å¾´:
- åˆå›å®Ÿè¡Œã®è‡ªå‹•æ¤œå‡º
- æ®µéšçš„åˆæœŸåŒ–ãƒ—ãƒ­ã‚»ã‚¹
- åˆæœŸåŒ–å¤±æ•—æ™‚ã®è‡ªå‹•å¾©æ—§
- ç¶™ç¶šå‡¦ç†ã¸ã®è‡ªå‹•ç§»è¡Œ
"""

class SystemInitializationManager:
    """
    ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼

    è²¬ä»»:
    - åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ã¨ç¶™ç¶šå‡¦ç†ã®çµ±åˆç®¡ç†
    - åˆæœŸåŒ–çŠ¶æ…‹ã®ç®¡ç†
    - åˆå›å®Ÿè¡Œã¨ç¶™ç¶šå®Ÿè¡Œã®åˆ‡ã‚Šæ›¿ãˆ
    - ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã®ç›£è¦–
    """

    def __init__(self, session: AsyncSession):
        self.session = session
        self.initial_loader = InitialDataLoaderService(session)
        self.continuous_service = ContinuousProcessingService(session)
        self.monitor = ContinuousProcessingMonitor()

        # åˆæœŸåŒ–çŠ¶æ…‹
        self.initialization_status = {
            "is_initialized": False,
            "initialization_date": None,
            "data_counts": {},
            "indicator_counts": {},
            "pattern_counts": {}
        }

    async def check_initialization_status(self) -> bool:
        """
        åˆæœŸåŒ–çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯

        Returns:
            bool: åˆæœŸåŒ–æ¸ˆã¿ãƒ•ãƒ©ã‚°
        """
        # å®Ÿè£…è©³ç´°...

    async def perform_initial_initialization(self) -> Dict[str, Any]:
        """
        åˆå›åˆæœŸåŒ–ã‚’å®Ÿè¡Œ

        Returns:
            Dict[str, Any]: åˆæœŸåŒ–çµæœ
        """
        # å®Ÿè£…è©³ç´°...

    async def start_continuous_processing(self) -> bool:
        """
        ç¶™ç¶šå‡¦ç†ã‚’é–‹å§‹

        Returns:
            bool: é–‹å§‹æˆåŠŸãƒ•ãƒ©ã‚°
        """
        # å®Ÿè£…è©³ç´°...

    async def run_system_cycle(self) -> Dict[str, Any]:
        """
        ã‚·ã‚¹ãƒ†ãƒ ã‚µã‚¤ã‚¯ãƒ«ã‚’å®Ÿè¡Œï¼ˆåˆæœŸåŒ–ãƒã‚§ãƒƒã‚¯ + ç¶™ç¶šå‡¦ç†ï¼‰

        Returns:
            Dict[str, Any]: å®Ÿè¡Œçµæœ
        """
        # å®Ÿè£…è©³ç´°...
```

### 4. ç¶™ç¶šå‡¦ç†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼

#### ãƒ•ã‚¡ã‚¤ãƒ«: `src/infrastructure/schedulers/continuous_processing_scheduler.py`

```python
"""
ç¶™ç¶šå‡¦ç†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼

è²¬ä»»:
- 5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿å–å¾—ã®å®šæœŸå®Ÿè¡Œ
- ç¶™ç¶šå‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®çµ±åˆç®¡ç†
- ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¨ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½
- ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ã¨ãƒ­ã‚°è¨˜éŒ²

ç‰¹å¾´:
- 5åˆ†é–“éš”ã§ã®è‡ªå‹•å®Ÿè¡Œ
- åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
- è‡ªå‹•å¾©æ—§æ©Ÿèƒ½
"""

class ContinuousProcessingScheduler:
    """
    ç¶™ç¶šå‡¦ç†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼

    è²¬ä»»:
    - 5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿å–å¾—ã®å®šæœŸå®Ÿè¡Œ
    - ç¶™ç¶šå‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®çµ±åˆç®¡ç†
    - ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¨ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½
    - ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ã¨ãƒ­ã‚°è¨˜éŒ²
    """

    def __init__(self):
        self.running = False
        self.session = None
        self.continuous_service = None

        # ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼è¨­å®š
        self.interval_minutes = 5
        self.max_retries = 3
        self.retry_delay = 30  # ç§’

        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_runs": 0,
            "successful_runs": 0,
            "failed_runs": 0,
            "last_run": None,
            "last_error": None,
            "processing_times": []
        }

    async def start(self):
        """
        ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ã‚’é–‹å§‹
        """
        # å®Ÿè£…è©³ç´°...

    async def stop(self):
        """
        ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ã‚’åœæ­¢
        """
        # å®Ÿè£…è©³ç´°...

    async def run_single_cycle(self):
        """
        å˜ä¸€ã‚µã‚¤ã‚¯ãƒ«ã®å®Ÿè¡Œ
        """
        # å®Ÿè£…è©³ç´°...

    async def _fetch_and_process_data(self):
        """
        ãƒ‡ãƒ¼ã‚¿å–å¾—ã¨å‡¦ç†ã‚’å®Ÿè¡Œ
        """
        # å®Ÿè£…è©³ç´°...
```

### 5. ç¶™ç¶šå‡¦ç†ç›£è¦–ã‚µãƒ¼ãƒ“ã‚¹

#### ãƒ•ã‚¡ã‚¤ãƒ«: `src/infrastructure/monitoring/continuous_processing_monitor.py`

```python
"""
ç¶™ç¶šå‡¦ç†ç›£è¦–ã‚µãƒ¼ãƒ“ã‚¹

è²¬ä»»:
- ç¶™ç¶šå‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç›£è¦–
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™ã®åé›†
- ã‚¨ãƒ©ãƒ¼æ¤œå‡ºã¨ã‚¢ãƒ©ãƒ¼ãƒˆ
- ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ã®ç›£è¦–

ç‰¹å¾´:
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–
- è‡ªå‹•ã‚¢ãƒ©ãƒ¼ãƒˆæ©Ÿèƒ½
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ
- éšœå®³æ¤œçŸ¥
"""

class ContinuousProcessingMonitor:
    """
    ç¶™ç¶šå‡¦ç†ç›£è¦–ã‚µãƒ¼ãƒ“ã‚¹

    è²¬ä»»:
    - ç¶™ç¶šå‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç›£è¦–
    - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™ã®åé›†
    - ã‚¨ãƒ©ãƒ¼æ¤œå‡ºã¨ã‚¢ãƒ©ãƒ¼ãƒˆ
    - ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ã®ç›£è¦–
    """

    def __init__(self):
        self.metrics = {
            "processing_times": [],
            "error_counts": {},
            "success_rates": {},
            "data_volumes": {}
        }

        # ç›£è¦–è¨­å®š
        self.alert_thresholds = {
            "max_processing_time": 300,  # 5åˆ†
            "min_success_rate": 0.95,    # 95%
            "max_error_count": 5         # 5å›
        }

    async def monitor_processing_cycle(self, cycle_data: Dict[str, Any]):
        """
        å‡¦ç†ã‚µã‚¤ã‚¯ãƒ«ã®ç›£è¦–

        Args:
            cycle_data: ã‚µã‚¤ã‚¯ãƒ«å®Ÿè¡Œãƒ‡ãƒ¼ã‚¿
        """
        # å®Ÿè£…è©³ç´°...

    async def check_system_health(self) -> Dict[str, Any]:
        """
        ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯

        Returns:
            Dict[str, Any]: å¥å…¨æ€§æƒ…å ±
        """
        # å®Ÿè£…è©³ç´°...

    async def send_alert(self, alert_type: str, message: str):
        """
        ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡

        Args:
            alert_type: ã‚¢ãƒ©ãƒ¼ãƒˆã‚¿ã‚¤ãƒ—
            message: ã‚¢ãƒ©ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        """
        # å®Ÿè£…è©³ç´°...
```

## ğŸ”§ å®Ÿè£…è©³ç´°

### 1. åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ã®å®Ÿè£…

#### åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ•ãƒ­ãƒ¼

```python
async def load_all_initial_data(self) -> Dict[str, Any]:
    """
    å…¨æ™‚é–“è»¸ã®åˆå›ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    """
    start_time = time.time()
    results = {
        "data_counts": {},
        "indicator_counts": {},
        "pattern_counts": {},
        "processing_time": 0
    }

    try:
        logger.info("=== åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—é–‹å§‹ ===")

        # 1. å„æ™‚é–“è»¸ã®ãƒ‡ãƒ¼ã‚¿ã‚’é †æ¬¡å–å¾—ï¼ˆAPIåˆ¶é™å¯¾å¿œï¼‰
        for timeframe, config in self.initial_load_config.items():
            logger.info(f"ğŸ“Š {config['description']}ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­...")

            data_count = await self.load_timeframe_data(timeframe)
            results["data_counts"][timeframe] = data_count

            logger.info(f"âœ… {config['description']}å®Œäº†: {data_count}ä»¶")

            # APIåˆ¶é™ã‚’è€ƒæ…®ã—ãŸå¾…æ©Ÿ
            if timeframe != "1d":  # æœ€å¾Œã®æ™‚é–“è»¸ä»¥å¤–ã§å¾…æ©Ÿ
                await asyncio.sleep(self.retry_delay)

        # 2. åˆå›ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—
        logger.info("ğŸ“ˆ åˆå›ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—ä¸­...")
        indicator_results = await self.calculate_initial_indicators()
        results["indicator_counts"] = indicator_results

        # 3. åˆå›ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º
        logger.info("ğŸ” åˆå›ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºä¸­...")
        pattern_results = await self.detect_initial_patterns()
        results["pattern_counts"] = pattern_results

        # 4. åˆæœŸåŒ–å®Œäº†ç¢ºèª
        is_initialized = await self.verify_initialization()

        results["processing_time"] = time.time() - start_time
        results["is_initialized"] = is_initialized

        logger.info("ğŸ‰ åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—å®Œäº†")
        return results

    except Exception as e:
        logger.error(f"åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
        raise
```

#### æ™‚é–“è»¸åˆ¥ãƒ‡ãƒ¼ã‚¿å–å¾—

```python
async def load_timeframe_data(self, timeframe: str) -> int:
    """
    ç‰¹å®šæ™‚é–“è»¸ã®åˆå›ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    """
    try:
        config = self.initial_load_config[timeframe]

        # æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ãƒã‚§ãƒƒã‚¯
        existing_count = await self.price_repo.count_by_date_range(
            datetime.now() - timedelta(days=7),
            datetime.now(),
            self.currency_pair
        )

        if existing_count > 100:  # ååˆ†ãªãƒ‡ãƒ¼ã‚¿ãŒæ—¢ã«å­˜åœ¨
            logger.info(f"  âš ï¸ {config['description']}ãƒ‡ãƒ¼ã‚¿ã¯æ—¢ã«å­˜åœ¨: {existing_count}ä»¶")
            return existing_count

        # Yahoo Financeã‹ã‚‰å±¥æ­´ãƒ‡ãƒ¼ã‚¿å–å¾—
        hist_data = await self.yahoo_client.get_historical_data(
            self.currency_pair,
            config["period"],
            config["interval"]
        )

        if hist_data is None or hist_data.empty:
            logger.warning(f"  âŒ {config['description']}ãƒ‡ãƒ¼ã‚¿å–å¾—å¤±æ•—")
            return 0

        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
        saved_count = 0
        for timestamp, row in hist_data.iterrows():
            price_data = PriceDataModel(
                currency_pair=self.currency_pair,
                timestamp=timestamp,
                open_price=float(row["Open"]),
                high_price=float(row["High"]),
                low_price=float(row["Low"]),
                close_price=float(row["Close"]),
                volume=int(row["Volume"]) if "Volume" in row else 1000000,
                data_source="Yahoo Finance Initial Load"
            )

            # é‡è¤‡ãƒã‚§ãƒƒã‚¯
            existing = await self.price_repo.find_by_timestamp(
                timestamp, self.currency_pair
            )
            if not existing:
                await self.price_repo.save(price_data)
                saved_count += 1

        logger.info(f"  âœ… {config['description']}ä¿å­˜å®Œäº†: {saved_count}ä»¶")
        return saved_count

    except Exception as e:
        logger.error(f"  âŒ {timeframe}ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
        return 0
```

### 2. ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®å®Ÿè£…

#### åˆæœŸåŒ–çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯

```python
async def check_initialization_status(self) -> bool:
    """
    åˆæœŸåŒ–çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
    """
    try:
        # å„æ™‚é–“è»¸ã®ãƒ‡ãƒ¼ã‚¿å­˜åœ¨ç¢ºèª
        timeframes = ["5m", "1h", "4h", "1d"]
        min_data_counts = {"5m": 100, "1h": 50, "4h": 30, "1d": 30}

        for timeframe in timeframes:
            data_count = await self.price_repo.count_by_date_range(
                datetime.now() - timedelta(days=7),
                datetime.now(),
                self.currency_pair
            )

            if data_count < min_data_counts[timeframe]:
                logger.info(f"åˆæœŸåŒ–æœªå®Œäº†: {timeframe}ãƒ‡ãƒ¼ã‚¿ä¸è¶³ ({data_count}/{min_data_counts[timeframe]})")
                return False

        # ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã®å­˜åœ¨ç¢ºèª
        indicator_count = await self.indicator_service.count_latest_indicators()
        if indicator_count < 50:
            logger.info(f"åˆæœŸåŒ–æœªå®Œäº†: ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ä¸è¶³ ({indicator_count}/50)")
            return False

        logger.info("åˆæœŸåŒ–å®Œäº†ç¢ºèªæ¸ˆã¿")
        return True

    except Exception as e:
        logger.error(f"åˆæœŸåŒ–çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}")
        return False
```

#### ã‚·ã‚¹ãƒ†ãƒ ã‚µã‚¤ã‚¯ãƒ«å®Ÿè¡Œ

```python
async def run_system_cycle(self) -> Dict[str, Any]:
    """
    ã‚·ã‚¹ãƒ†ãƒ ã‚µã‚¤ã‚¯ãƒ«ã‚’å®Ÿè¡Œï¼ˆåˆæœŸåŒ–ãƒã‚§ãƒƒã‚¯ + ç¶™ç¶šå‡¦ç†ï¼‰
    """
    try:
        # 1. åˆæœŸåŒ–çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
        is_initialized = await self.check_initialization_status()

        if not is_initialized:
            logger.info("=== åˆå›åˆæœŸåŒ–ã‚’å®Ÿè¡Œ ===")
            return await self.perform_initial_initialization()
        else:
            logger.info("=== ç¶™ç¶šå‡¦ç†ã‚’å®Ÿè¡Œ ===")
            return await self.continuous_service.process_latest_data()

    except Exception as e:
        logger.error(f"ã‚·ã‚¹ãƒ†ãƒ ã‚µã‚¤ã‚¯ãƒ«ã‚¨ãƒ©ãƒ¼: {e}")
        raise
```

### 3. ç¶™ç¶šå‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å®Ÿè£…

#### ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ­ãƒ¼

```python
async def process_5m_data(self, price_data: PriceDataModel) -> Dict[str, Any]:
    """
    5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ã®ç¶™ç¶šå‡¦ç†ã‚’å®Ÿè¡Œ
    """
    start_time = time.time()
    results = {
        "aggregation": {},
        "indicators": {},
        "patterns": {},
        "notifications": {},
        "processing_time": 0
    }

    try:
        # 1. 5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
        saved_data = await self.price_repo.save(price_data)

        # 2. æ™‚é–“è»¸é›†è¨ˆã‚’å®Ÿè¡Œ
        aggregation_results = await self.aggregate_timeframes()
        results["aggregation"] = aggregation_results

        # 3. ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™ã‚’è¨ˆç®—
        indicator_results = await self.calculate_all_indicators()
        results["indicators"] = indicator_results

        # 4. ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºã‚’å®Ÿè¡Œ
        pattern_results = await self.detect_patterns()
        results["patterns"] = pattern_results

        # 5. é€šçŸ¥å‡¦ç†
        notification_results = await self.process_notifications()
        results["notifications"] = notification_results

        # å‡¦ç†æ™‚é–“ã‚’è¨˜éŒ²
        results["processing_time"] = time.time() - start_time

        return results

    except Exception as e:
        logger.error(f"ç¶™ç¶šå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
        raise
```

#### æ™‚é–“è»¸é›†è¨ˆã®å®Ÿè£…

```python
async def aggregate_1h_data(self) -> List[PriceDataModel]:
    """
    5åˆ†è¶³ã‹ã‚‰1æ™‚é–“è¶³ãƒ‡ãƒ¼ã‚¿ã‚’é›†è¨ˆ
    """
    try:
        # éå»1æ™‚é–“ã®5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        end_date = datetime.now()
        start_date = end_date - timedelta(hours=1)

        m5_data = await self.price_repo.find_by_date_range_and_timeframe(
            start_date, end_date, self.currency_pair, "5m", 1000
        )

        if len(m5_data) < 12:  # 1æ™‚é–“ = 12å€‹ã®5åˆ†è¶³
            logger.warning("1æ™‚é–“è¶³é›†è¨ˆã«å¿…è¦ãª5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³")
            return []

        # DataFrameã«å¤‰æ›
        df = self._convert_to_dataframe(m5_data)

        # 1æ™‚é–“è¶³ã«é›†è¨ˆ
        h1_df = self._aggregate_timeframe_data(df, "1H")

        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
        saved_data = []
        for timestamp, row in h1_df.iterrows():
            price_data = PriceDataModel(
                currency_pair=self.currency_pair,
                timestamp=timestamp,
                open_price=float(row["Open"]),
                high_price=float(row["High"]),
                low_price=float(row["Low"]),
                close_price=float(row["Close"]),
                volume=int(row["Volume"]),
                data_source="Aggregated from 5m"
            )

            # é‡è¤‡ãƒã‚§ãƒƒã‚¯
            existing = await self.price_repo.find_by_timestamp(
                timestamp, self.currency_pair
            )
            if not existing:
                saved_data.append(await self.price_repo.save(price_data))

        logger.info(f"1æ™‚é–“è¶³é›†è¨ˆå®Œäº†: {len(saved_data)}ä»¶")
        return saved_data

    except Exception as e:
        logger.error(f"1æ™‚é–“è¶³é›†è¨ˆã‚¨ãƒ©ãƒ¼: {e}")
        return []
```

### 2. ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ã®å®Ÿè£…

#### å®šæœŸå®Ÿè¡Œãƒ•ãƒ­ãƒ¼

```python
async def run_single_cycle(self):
    """
    å˜ä¸€ã‚µã‚¤ã‚¯ãƒ«ã®å®Ÿè¡Œ
    """
    start_time = time.time()
    self.stats["total_runs"] += 1

    try:
        logger.info(f"ç¶™ç¶šå‡¦ç†ã‚µã‚¤ã‚¯ãƒ« #{self.stats['total_runs']} é–‹å§‹")

        # 1. 5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        price_data = await self._fetch_5m_data()
        if not price_data:
            raise Exception("5åˆ†è¶³ãƒ‡ãƒ¼ã‚¿å–å¾—å¤±æ•—")

        # 2. ç¶™ç¶šå‡¦ç†ã‚’å®Ÿè¡Œ
        results = await self.continuous_service.process_5m_data(price_data)

        # 3. çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°
        processing_time = time.time() - start_time
        self.stats["processing_times"].append(processing_time)
        self.stats["successful_runs"] += 1
        self.stats["last_run"] = datetime.now()

        logger.info(f"ç¶™ç¶šå‡¦ç†ã‚µã‚¤ã‚¯ãƒ«å®Œäº†: {processing_time:.2f}ç§’")
        logger.info(f"çµæœ: é›†è¨ˆ={results['aggregation']}, æŒ‡æ¨™={results['indicators']}, ãƒ‘ã‚¿ãƒ¼ãƒ³={results['patterns']}")

    except Exception as e:
        self.stats["failed_runs"] += 1
        self.stats["last_error"] = str(e)
        logger.error(f"ç¶™ç¶šå‡¦ç†ã‚µã‚¤ã‚¯ãƒ«ã‚¨ãƒ©ãƒ¼: {e}")

        # ãƒªãƒˆãƒ©ã‚¤å‡¦ç†
        await self._handle_error(e)
```

### 3. ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

#### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

```python
async def monitor_processing_cycle(self, cycle_data: Dict[str, Any]):
    """
    å‡¦ç†ã‚µã‚¤ã‚¯ãƒ«ã®ç›£è¦–
    """
    try:
        # å‡¦ç†æ™‚é–“ã‚’è¨˜éŒ²
        processing_time = cycle_data.get("processing_time", 0)
        self.metrics["processing_times"].append(processing_time)

        # å‡¦ç†æ™‚é–“ã®é–¾å€¤ãƒã‚§ãƒƒã‚¯
        if processing_time > self.alert_thresholds["max_processing_time"]:
            await self.send_alert(
                "PERFORMANCE",
                f"å‡¦ç†æ™‚é–“ãŒé–¾å€¤ã‚’è¶…é: {processing_time:.2f}ç§’"
            )

        # æˆåŠŸç‡ã‚’è¨ˆç®—
        total_runs = cycle_data.get("total_runs", 0)
        successful_runs = cycle_data.get("successful_runs", 0)

        if total_runs > 0:
            success_rate = successful_runs / total_runs
            self.metrics["success_rates"]["overall"] = success_rate

            if success_rate < self.alert_thresholds["min_success_rate"]:
                await self.send_alert(
                    "RELIABILITY",
                    f"æˆåŠŸç‡ãŒé–¾å€¤ã‚’ä¸‹å›ã‚‹: {success_rate:.2%}"
                )

        # ãƒ‡ãƒ¼ã‚¿é‡ã‚’è¨˜éŒ²
        data_volume = cycle_data.get("data_volume", 0)
        self.metrics["data_volumes"].append(data_volume)

    except Exception as e:
        logger.error(f"ç›£è¦–å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
```

## ğŸ“Š è¨­å®šã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

### 1. æ™‚é–“è»¸è¨­å®š

```python
TIMEFRAME_CONFIG = {
    "5m": {
        "interval": "5m",
        "minutes": 5,
        "description": "5åˆ†è¶³",
        "aggregation_source": None
    },
    "1h": {
        "interval": "1h",
        "minutes": 60,
        "description": "1æ™‚é–“è¶³",
        "aggregation_source": "5m",
        "aggregation_rule": "12_5m_periods"
    },
    "4h": {
        "interval": "4h",
        "minutes": 240,
        "description": "4æ™‚é–“è¶³",
        "aggregation_source": "5m",
        "aggregation_rule": "48_5m_periods"
    }
}
```

### 2. ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨­å®š

```python
TECHNICAL_INDICATOR_CONFIG = {
    "rsi": {
        "period": 14,
        "overbought": 70,
        "oversold": 30
    },
    "macd": {
        "fast_period": 12,
        "slow_period": 26,
        "signal_period": 9
    },
    "bollinger_bands": {
        "period": 20,
        "std_dev": 2.0
    }
}
```

### 3. ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºè¨­å®š

```python
PATTERN_DETECTION_CONFIG = {
    "breakout": {
        "min_confidence": 70.0,
        "volume_threshold": 1.5
    },
    "trend_reversal": {
        "min_confidence": 75.0,
        "confirmation_periods": 3
    },
    "rsi_battle": {
        "min_confidence": 80.0,
        "battle_threshold": 50.0
    }
}
```

## ğŸš€ å®Ÿè£…è¨ˆç”»

### Phase 1: åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚·ã‚¹ãƒ†ãƒ ï¼ˆ1 é€±é–“ï¼‰

1. **InitialDataLoaderService**ã®å®Ÿè£…
2. **SystemInitializationManager**ã®å®Ÿè£…
3. åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ã®ãƒ†ã‚¹ãƒˆ

### Phase 2: ç¶™ç¶šå‡¦ç†åŸºç›¤ï¼ˆ1 é€±é–“ï¼‰

1. **TimeframeAggregatorService**ã®å®Ÿè£…
2. **ContinuousProcessingService**ã®å®Ÿè£…
3. åŸºæœ¬çš„ãªçµ±åˆãƒ†ã‚¹ãƒˆ

### Phase 3: ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼å®Ÿè£…ï¼ˆ1 é€±é–“ï¼‰

1. **ContinuousProcessingScheduler**ã®å®Ÿè£…
2. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½
3. åŸºæœ¬çš„ãªç›£è¦–æ©Ÿèƒ½

### Phase 4: ç›£è¦–ãƒ»æœ€é©åŒ–ï¼ˆ1 é€±é–“ï¼‰

1. **ContinuousProcessingMonitor**ã®å®Ÿè£…
2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
3. åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆ

### Phase 5: æœ¬ç•ªçµ±åˆï¼ˆ1 é€±é–“ï¼‰

1. æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã¨ã®çµ±åˆ
2. æœ¬ç•ªç’°å¢ƒã§ã®ãƒ†ã‚¹ãƒˆ
3. é‹ç”¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆ

## ğŸ“ˆ æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ

### 1. ã‚·ã‚¹ãƒ†ãƒ ä¿¡é ¼æ€§ã®å‘ä¸Š

- **åˆå›ãƒ‡ãƒ¼ã‚¿å–å¾—ã®ç¢ºå®Ÿæ€§**: API åˆ¶é™ã‚’è€ƒæ…®ã—ãŸæ®µéšçš„ãƒ‡ãƒ¼ã‚¿å–å¾—
- **ç¶™ç¶šçš„ãªãƒ†ã‚¯ãƒ‹ã‚«ãƒ«æŒ‡æ¨™è¨ˆç®—**: 5 åˆ†è¶³ãƒ‡ãƒ¼ã‚¿ã®ã¿ã§ã®ç¶™ç¶šå‡¦ç†
- **å®‰å®šã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º**: ååˆ†ãªãƒ‡ãƒ¼ã‚¿é‡ã§ã®é«˜ç²¾åº¦æ¤œå‡º
- **è‡ªå‹•ã‚¨ãƒ©ãƒ¼å¾©æ—§**: åˆæœŸåŒ–å¤±æ•—æ™‚ã®è‡ªå‹•å†è©¦è¡Œ

### 2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æ”¹å–„

- **åŠ¹ç‡çš„ãªãƒ‡ãƒ¼ã‚¿é›†è¨ˆ**: 5 åˆ†è¶³ã‹ã‚‰ã®è‡ªå‹•æ™‚é–“è»¸é›†è¨ˆ
- **æœ€é©åŒ–ã•ã‚ŒãŸå‡¦ç†ãƒ•ãƒ­ãƒ¼**: åˆå›å®Ÿè¡Œã¨ç¶™ç¶šå®Ÿè¡Œã®æœ€é©åŒ–
- **ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡ã®å‰Šæ¸›**: API å‘¼ã³å‡ºã—å›æ•°ã®æœ€å°åŒ–
- **é«˜é€ŸãªåˆæœŸåŒ–**: ä¸¦åˆ—å‡¦ç†ã«ã‚ˆã‚‹åˆæœŸåŒ–æ™‚é–“çŸ­ç¸®

### 3. é‹ç”¨åŠ¹ç‡ã®å‘ä¸Š

- **è‡ªå‹•åŒ–ã•ã‚ŒãŸç¶™ç¶šå‡¦ç†**: äººæ‰‹ä»‹å…¥ä¸è¦ã®å®Œå…¨è‡ªå‹•åŒ–
- **åŒ…æ‹¬çš„ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ **: åˆæœŸåŒ–ã‹ã‚‰ç¶™ç¶šå‡¦ç†ã¾ã§ã®çµ±åˆç›£è¦–
- **è¿…é€Ÿãªå•é¡Œæ¤œçŸ¥**: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ãƒ©ãƒ¼ãƒˆæ©Ÿèƒ½
- **æŸ”è»Ÿãªè¨­å®šç®¡ç†**: æ™‚é–“è»¸ã‚„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹•çš„èª¿æ•´

---

**ğŸ”„ Exchange Analytics System** - _Multi-Timeframe Continuous Processing Design_
